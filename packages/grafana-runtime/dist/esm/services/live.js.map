{"version":3,"file":"live.js","sources":["../../../src/services/live.ts"],"sourcesContent":["import { Observable } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryRequest,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelEvent,\n  LiveChannelPresenceStatus,\n  StreamingFrameOptions,\n} from '@grafana/data';\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveDataFilter {\n  fields?: string[];\n}\n\n// StreamingFrameAction and StreamingFrameOptions are now in @grafana/data\nexport { StreamingFrameAction, type StreamingFrameOptions } from '@grafana/data';\n\n/**\n * @alpha\n */\nexport interface LiveDataStreamOptions {\n  addr: LiveChannelAddress;\n  frame?: DataFrameJSON; // initial results\n  key?: string;\n  buffer?: Partial<StreamingFrameOptions>;\n  filter?: LiveDataFilter;\n}\n\n/**\n * @alpha -- experimental: send a normal query request over websockt\n */\nexport interface LiveQueryDataOptions {\n  request: DataQueryRequest;\n  body: unknown; // processed queries, same as sent to `/api/query/ds`\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface GrafanaLiveSrv {\n  /**\n   * Listen for changes to the main service\n   */\n  getConnectionState(): Observable<boolean>;\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream<T>(address: LiveChannelAddress): Observable<LiveChannelEvent<T>>;\n\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream(options: LiveDataStreamOptions): Observable<DataQueryResponse>;\n\n  /**\n   * Execute a query over the live websocket and potentiall subscribe to a live channel.\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   *\n   * @alpha -- this function requires the feature toggle `queryOverLive` to be set\n   */\n  getQueryData(options: LiveQueryDataOptions): Observable<DataQueryResponse>;\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence(address: LiveChannelAddress): Promise<LiveChannelPresenceStatus>;\n\n  /**\n   * Publish into a channel\n   *\n   * @alpha -- experimental\n   */\n  publish(address: LiveChannelAddress, data: unknown): Promise<unknown>;\n}\n\nlet singletonInstance: GrafanaLiveSrv;\n\n/**\n * Used during startup by Grafana to set the GrafanaLiveSrv so it is available\n * via the {@link getGrafanaLiveSrv} to the rest of the application.\n *\n * @internal\n */\nexport const setGrafanaLiveSrv = (instance: GrafanaLiveSrv) => {\n  singletonInstance = instance;\n};\n\n/**\n * Used to retrieve the GrafanaLiveSrv that allows you to subscribe to\n * server side events and streams\n *\n * @alpha -- experimental\n */\nexport const getGrafanaLiveSrv = (): GrafanaLiveSrv => singletonInstance;\n"],"names":[],"mappings":";;AAoFA,IAAI,iBAAA,CAAA;AAQS,MAAA,iBAAA,GAAoB,CAAC,QAA6B,KAAA;AAC7D,EAAoB,iBAAA,GAAA,QAAA,CAAA;AACtB,EAAA;AAQO,MAAM,oBAAoB,MAAsB;;;;"}