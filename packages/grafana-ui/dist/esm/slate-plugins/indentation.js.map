{"version":3,"file":"indentation.js","sources":["../../../src/slate-plugins/indentation.ts"],"sourcesContent":["import { isKeyHotkey } from 'is-hotkey';\nimport React from 'react';\nimport { RangeJSON, Range as SlateRange } from 'slate';\nimport Plain from 'slate-plain-serializer';\nimport { Editor, Plugin } from 'slate-react';\n\nconst isIndentLeftHotkey = isKeyHotkey('mod+[');\nconst isShiftTabHotkey = isKeyHotkey('shift+tab');\nconst isIndentRightHotkey = isKeyHotkey('mod+]');\n\nconst SLATE_TAB = '  ';\n\nconst handleTabKey = (event: React.KeyboardEvent<Element>, editor: Editor, next: Function): void => {\n  const {\n    startBlock,\n    endBlock,\n    selection: {\n      start: { offset: startOffset, key: startKey },\n      end: { offset: endOffset, key: endKey },\n    },\n  } = editor.value;\n  if (Plain.serialize(editor.value) === '') {\n    return;\n  }\n  event.preventDefault();\n  const first = startBlock.getFirstText();\n\n  const startBlockIsSelected =\n    first && startOffset === 0 && startKey === first.key && endOffset === first.text.length && endKey === first.key;\n\n  if (startBlockIsSelected || !startBlock.equals(endBlock)) {\n    handleIndent(editor, 'right');\n  } else {\n    editor.insertText(SLATE_TAB);\n  }\n};\n\nconst handleIndent = (editor: Editor, indentDirection: 'left' | 'right') => {\n  const curSelection = editor.value.selection;\n  const selectedBlocks = editor.value.document.getLeafBlocksAtRange(curSelection).toArray();\n\n  if (indentDirection === 'left') {\n    for (const block of selectedBlocks) {\n      const blockWhitespace = block.text.length - block.text.trimLeft().length;\n\n      const textKey = block.getFirstText()!.key;\n\n      const rangeProperties: RangeJSON = {\n        anchor: {\n          key: textKey,\n          offset: blockWhitespace,\n          path: [],\n        },\n        focus: {\n          key: textKey,\n          offset: blockWhitespace,\n          path: [],\n        },\n      };\n\n      editor.deleteBackwardAtRange(SlateRange.create(rangeProperties), Math.min(SLATE_TAB.length, blockWhitespace));\n    }\n  } else {\n    const { startText } = editor.value;\n    const textBeforeCaret = startText.text.slice(0, curSelection.start.offset);\n    const isWhiteSpace = /^\\s*$/.test(textBeforeCaret);\n\n    for (const block of selectedBlocks) {\n      editor.insertTextByKey(block.getFirstText()!.key, 0, SLATE_TAB);\n    }\n\n    if (isWhiteSpace) {\n      editor.moveStartBackward(SLATE_TAB.length);\n    }\n  }\n};\n\n// Clears the rest of the line after the caret\nexport function IndentationPlugin(): Plugin {\n  return {\n    onKeyDown(event, editor, next) {\n      if (isIndentLeftHotkey(event) || isShiftTabHotkey(event)) {\n        event.preventDefault();\n        handleIndent(editor, 'left');\n      } else if (isIndentRightHotkey(event)) {\n        event.preventDefault();\n        handleIndent(editor, 'right');\n      } else if (event.key === 'Tab') {\n        handleTabKey(event, editor, next);\n      } else {\n        return next();\n      }\n\n      return true;\n    },\n  };\n}\n"],"names":["SlateRange"],"mappings":"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"}