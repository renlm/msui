{"version":3,"file":"datemath.js","sources":["../../../src/datetime/datemath.ts"],"sourcesContent":["import { includes, isDate } from 'lodash';\n\nimport { TimeZone } from '../types/index';\n\nimport { DateTime, dateTime, dateTimeForTimeZone, DurationUnit, isDateTime, ISO_8601 } from './moment_wrapper';\n\nconst units: DurationUnit[] = ['y', 'M', 'w', 'd', 'h', 'm', 's', 'Q'];\n\n/**\n * Determine if a string contains a relative date time.\n * @param text\n */\nexport function isMathString(text: string | DateTime | Date): boolean {\n  if (!text) {\n    return false;\n  }\n\n  if (typeof text === 'string' && (text.substring(0, 3) === 'now' || text.includes('||'))) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Parses different types input to a moment instance. There is a specific formatting language that can be used\n * if text arg is string. See unit tests for examples.\n * @param text\n * @param roundUp See parseDateMath function.\n * @param timezone Only string 'utc' is acceptable here, for anything else, local timezone is used.\n */\nexport function parse(\n  text?: string | DateTime | Date | null,\n  roundUp?: boolean,\n  timezone?: TimeZone,\n  fiscalYearStartMonth?: number\n): DateTime | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n  if (typeof text !== 'string') {\n    if (isDateTime(text)) {\n      return text;\n    }\n    if (isDate(text)) {\n      return dateTime(text);\n    }\n    // We got some non string which is not a moment nor Date. TS should be able to check for that but not always.\n    return undefined;\n  } else {\n    let time;\n    let mathString = '';\n    let index;\n    let parseString;\n\n    if (text.substring(0, 3) === 'now') {\n      time = dateTimeForTimeZone(timezone);\n      mathString = text.substring('now'.length);\n    } else {\n      index = text.indexOf('||');\n      if (index === -1) {\n        parseString = text;\n        mathString = ''; // nothing else\n      } else {\n        parseString = text.substring(0, index);\n        mathString = text.substring(index + 2);\n      }\n      // We're going to just require ISO8601 timestamps, k?\n      time = dateTime(parseString, ISO_8601);\n    }\n\n    if (!mathString.length) {\n      return time;\n    }\n\n    return parseDateMath(mathString, time, roundUp, fiscalYearStartMonth);\n  }\n}\n\n/**\n * Checks if text is a valid date which in this context means that it is either a Moment instance or it can be parsed\n * by parse function. See parse function to see what is considered acceptable.\n * @param text\n */\nexport function isValid(text: string | DateTime): boolean {\n  const date = parse(text);\n  if (!date) {\n    return false;\n  }\n\n  if (isDateTime(date)) {\n    return date.isValid();\n  }\n\n  return false;\n}\n\n/**\n * Parses math part of the time string and shifts supplied time according to that math. See unit tests for examples.\n * @param mathString\n * @param time\n * @param roundUp If true it will round the time to endOf time unit, otherwise to startOf time unit.\n */\n// TODO: Had to revert Andrejs `time: moment.Moment` to `time: any`\nexport function parseDateMath(\n  mathString: string,\n  time: any,\n  roundUp?: boolean,\n  fiscalYearStartMonth = 0\n): DateTime | undefined {\n  const strippedMathString = mathString.replace(/\\s/g, '');\n  const result = dateTime(time);\n  let i = 0;\n  const len = strippedMathString.length;\n\n  while (i < len) {\n    const c = strippedMathString.charAt(i++);\n    let type;\n    let num;\n    let unitString: string;\n    let isFiscal = false;\n\n    if (c === '/') {\n      type = 0;\n    } else if (c === '+') {\n      type = 1;\n    } else if (c === '-') {\n      type = 2;\n    } else {\n      return undefined;\n    }\n\n    if (isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n      num = 1;\n    } else if (strippedMathString.length === 2) {\n      num = parseInt(strippedMathString.charAt(i), 10);\n    } else {\n      const numFrom = i;\n      while (!isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n        i++;\n        if (i > 10) {\n          return undefined;\n        }\n      }\n      num = parseInt(strippedMathString.substring(numFrom, i), 10);\n    }\n\n    if (type === 0) {\n      // rounding is only allowed on whole, single, units (eg M or 1M, not 0.5M or 2M)\n      if (num !== 1) {\n        return undefined;\n      }\n    }\n\n    unitString = strippedMathString.charAt(i++);\n\n    if (unitString === 'f') {\n      unitString = strippedMathString.charAt(i++);\n      isFiscal = true;\n    }\n\n    const unit = unitString as DurationUnit;\n\n    if (!includes(units, unit)) {\n      return undefined;\n    } else {\n      if (type === 0) {\n        if (isFiscal) {\n          roundToFiscal(fiscalYearStartMonth, result, unit, roundUp);\n        } else {\n          if (roundUp) {\n            result.endOf(unit);\n          } else {\n            result.startOf(unit);\n          }\n        }\n      } else if (type === 1) {\n        result.add(num, unit);\n      } else if (type === 2) {\n        result.subtract(num, unit);\n      }\n    }\n  }\n  return result;\n}\n\nexport function roundToFiscal(fyStartMonth: number, dateTime: any, unit: string, roundUp: boolean | undefined) {\n  switch (unit) {\n    case 'y':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false).add(11, 'M').endOf('M');\n      } else {\n        dateTime.subtract((dateTime.month() - fyStartMonth + 12) % 12, 'M').startOf('M');\n      }\n      return dateTime;\n    case 'Q':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false).add(2, 'M').endOf('M');\n      } else {\n        // why + 12? to ensure this number is always a positive offset from fyStartMonth\n        dateTime.subtract((dateTime.month() - fyStartMonth + 12) % 3, 'M').startOf('M');\n      }\n      return dateTime;\n    default:\n      return undefined;\n  }\n}\n"],"names":["dateTime"],"mappings":"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"}