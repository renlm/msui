{"version":3,"file":"live.js","sources":["../../../src/types/live.ts"],"sourcesContent":["/**\n * The channel id is defined as:\n *\n *   ${scope}/${namespace}/${path}\n *\n * The scope drives how the namespace is used and controlled\n *\n * @alpha\n */\nexport enum LiveChannelScope {\n  DataSource = 'ds', // namespace = data source ID\n  Plugin = 'plugin', // namespace = plugin name (singleton works for apps too)\n  Grafana = 'grafana', // namespace = feature\n  Stream = 'stream', // namespace = id for the managed data stream\n}\n\n/**\n * The type of data to expect in a given channel\n *\n * @alpha\n */\nexport enum LiveChannelType {\n  DataStream = 'stream', // each message contains a batch of rows that will be appended to previous values\n  DataFrame = 'frame', // each message is an entire data frame and should *replace* previous content\n  JSON = 'json', // arbitrary json message\n}\n\nexport enum LiveChannelConnectionState {\n  /** The connection is not yet established */\n  Pending = 'pending',\n  /** Connected to the channel */\n  Connected = 'connected',\n  /** Connecting to a channel */\n  Connecting = 'connecting',\n  /** Disconnected from the channel.  The channel will reconnect when possible */\n  Disconnected = 'disconnected',\n  /** Was at some point connected, and will not try to reconnect */\n  Shutdown = 'shutdown',\n  /** Channel configuration was invalid and will not connect */\n  Invalid = 'invalid',\n}\n\nexport enum LiveChannelEventType {\n  Status = 'status',\n  Join = 'join',\n  Leave = 'leave',\n  Message = 'message',\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelStatusEvent {\n  type: LiveChannelEventType.Status;\n\n  /**\n   * {scope}/{namespace}/{path}\n   */\n  id: string;\n\n  /**\n   * unix millies timestamp for the last status change\n   */\n  timestamp: number;\n\n  /**\n   * flag if the channel is actively connected to the channel.\n   * This may be false while the connections get established or if the network is lost\n   * As long as the `shutdown` flag is not set, the connection will try to reestablish\n   */\n  state: LiveChannelConnectionState;\n\n  /**\n   * When joining a channel, there may be an initial packet in the subscribe method\n   */\n  message?: any;\n\n  /**\n   * The last error.\n   *\n   * This will remain in the status until a new message is successfully received from the channel\n   */\n  error?: any;\n}\n\nexport interface LiveChannelJoinEvent {\n  type: LiveChannelEventType.Join;\n  user: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\nexport interface LiveChannelLeaveEvent {\n  type: LiveChannelEventType.Leave;\n  user: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\nexport interface LiveChannelMessageEvent<T> {\n  type: LiveChannelEventType.Message;\n  message: T;\n}\n\nexport type LiveChannelEvent<T = any> =\n  | LiveChannelStatusEvent\n  | LiveChannelJoinEvent\n  | LiveChannelLeaveEvent\n  | LiveChannelMessageEvent<T>;\n\nexport function isLiveChannelStatusEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelStatusEvent {\n  return evt.type === LiveChannelEventType.Status;\n}\n\nexport function isLiveChannelJoinEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelJoinEvent {\n  return evt.type === LiveChannelEventType.Join;\n}\n\nexport function isLiveChannelLeaveEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelLeaveEvent {\n  return evt.type === LiveChannelEventType.Leave;\n}\n\nexport function isLiveChannelMessageEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelMessageEvent<T> {\n  return evt.type === LiveChannelEventType.Message;\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelPresenceStatus {\n  users: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\n/**\n * @alpha -- experimental\n */\nexport type LiveChannelId = string;\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelAddress {\n  scope: LiveChannelScope;\n  namespace: string; // depends on the scope\n  path: string;\n\n  /**\n   * Additional metadata passed to a channel.  The backend will propagate this JSON object to\n   * each OnSubscribe and RunStream calls.  This value should be constant across multiple requests\n   * to the same channel path\n   */\n  data?: any;\n}\n\n/**\n * Return an address from a string\n *\n * @alpha -- experimental\n */\nexport function parseLiveChannelAddress(id?: string): LiveChannelAddress | undefined {\n  if (id?.length) {\n    let parts = id.trim().split('/');\n    if (parts.length >= 3) {\n      return {\n        scope: parts[0] as LiveChannelScope,\n        namespace: parts[1],\n        path: parts.slice(2).join('/'),\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Check if the address has a scope, namespace, and path\n *\n * @alpha -- experimental\n */\nexport function isValidLiveChannelAddress(addr?: LiveChannelAddress): addr is LiveChannelAddress {\n  return !!(addr?.path && addr.namespace && addr.scope);\n}\n\n/**\n * Convert the address to an explicit channel path\n *\n * @alpha -- experimental\n */\nexport function toLiveChannelId(addr: LiveChannelAddress): LiveChannelId {\n  if (!addr.scope) {\n    return '';\n  }\n  let id: string = addr.scope;\n  if (!addr.namespace) {\n    return id;\n  }\n  id += '/' + addr.namespace;\n  if (!addr.path) {\n    return id;\n  }\n  return id + '/' + addr.path;\n}\n"],"names":["LiveChannelScope","LiveChannelType","LiveChannelConnectionState","LiveChannelEventType"],"mappings":"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"}