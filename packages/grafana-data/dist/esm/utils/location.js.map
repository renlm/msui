{"version":3,"file":"location.js","sources":["../../../src/utils/location.ts"],"sourcesContent":["import { Location } from 'history';\n\nimport { textUtil } from '../text';\nimport { GrafanaConfig, RawTimeRange, ScopedVars } from '../types';\n\nimport { UrlQueryMap, urlUtil } from './url';\n\nlet grafanaConfig = { appSubUrl: '' } as GrafanaConfig;\nlet getTimeRangeUrlParams: () => RawTimeRange;\nlet getVariablesUrlParams: (scopedVars?: ScopedVars) => UrlQueryMap;\n\nconst maybeParseUrl = (input: string): URL | undefined => {\n  try {\n    return new URL(input);\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n *\n * @param url\n * @internal\n */\nconst stripBaseFromUrl = (urlOrPath: string): string => {\n  // Will only return a URL object if the input is actually a valid URL\n  const parsedUrl = maybeParseUrl(urlOrPath);\n  if (parsedUrl) {\n    // If the input is a URL, and for a different origin that we're on, just bail\n    // and return it. There's no need to strip anything from it\n    if (parsedUrl.origin !== window.location.origin) {\n      return urlOrPath;\n    }\n  }\n\n  const appSubUrl = grafanaConfig.appSubUrl ?? '';\n  const stripExtraChars = appSubUrl.endsWith('/') ? 1 : 0;\n  const isAbsoluteUrl = urlOrPath.startsWith('http');\n\n  let segmentToStrip = appSubUrl;\n\n  if (!urlOrPath.startsWith('/') || isAbsoluteUrl) {\n    segmentToStrip = `${window.location.origin}${appSubUrl}`;\n  }\n\n  // Check if the segment is either exactly the same as the url\n  // or followed by a '/' so it does not replace incorrect similarly named segments\n  // i.e. /grafana should not replace /grafanadashboards\n  return urlOrPath.length > 0 && (urlOrPath.indexOf(segmentToStrip + '/') === 0 || urlOrPath === segmentToStrip)\n    ? urlOrPath.slice(segmentToStrip.length - stripExtraChars)\n    : urlOrPath;\n};\n\n/**\n *\n * @param url\n * @internal\n */\nconst assureBaseUrl = (url: string): string => {\n  if (url.startsWith('/')) {\n    return `${grafanaConfig.appSubUrl}${stripBaseFromUrl(url)}`;\n  }\n  return url;\n};\n\n/**\n *\n * @param location\n * @param searchParamsToUpdate\n * @returns\n */\nconst getUrlForPartial = (location: Location, searchParamsToUpdate: UrlQueryMap) => {\n  const searchParams = urlUtil.parseKeyValue(\n    location.search.startsWith('?') ? location.search.substring(1) : location.search\n  );\n  for (const key in searchParamsToUpdate) {\n    // removing params with null | undefined\n    if (searchParamsToUpdate[key] === null || searchParamsToUpdate[key] === undefined) {\n      delete searchParams[key];\n    } else {\n      searchParams[key] = searchParamsToUpdate[key];\n    }\n  }\n  return assureBaseUrl(urlUtil.renderUrl(location.pathname, searchParams));\n};\n\n/**\n * @deprecated use `getUrlForPartial` instead\n * Update URL or search param string `init` with new params `partial`.\n */\nconst updateSearchParams = (init: string, partial: string) => {\n  const urlSearchParams = new URLSearchParams(partial);\n\n  // Check if full URL\n  try {\n    const curURL = new URL(init);\n    urlSearchParams.forEach((val, key) => curURL.searchParams.set(key, val));\n    return curURL.href;\n  } catch {\n    // assume search params\n    const newSearchParams = new URLSearchParams(init);\n    urlSearchParams.forEach((v, k) => {\n      newSearchParams.set(k, v);\n    });\n    return '?' + newSearchParams.toString();\n  }\n};\n\ninterface LocationUtilDependencies {\n  config: GrafanaConfig;\n  getTimeRangeForUrl: () => RawTimeRange;\n  getVariablesUrlParams: (scopedVars?: ScopedVars) => UrlQueryMap;\n}\n\nexport const locationUtil = {\n  /**\n   *\n   * @param getConfig\n   * @param getAllVariableValuesForUrl\n   * @param getTimeRangeForUrl\n   * @internal\n   */\n  initialize: (dependencies: LocationUtilDependencies) => {\n    grafanaConfig = dependencies.config;\n    getTimeRangeUrlParams = dependencies.getTimeRangeForUrl;\n    getVariablesUrlParams = dependencies.getVariablesUrlParams;\n  },\n  stripBaseFromUrl,\n  assureBaseUrl,\n  updateSearchParams,\n  getTimeRangeUrlParams: () => {\n    if (!getTimeRangeUrlParams) {\n      return null;\n    }\n    return urlUtil.toUrlParams(getTimeRangeUrlParams());\n  },\n  getVariablesUrlParams: (scopedVars?: ScopedVars) => {\n    if (!getVariablesUrlParams) {\n      return null;\n    }\n    const params = getVariablesUrlParams(scopedVars);\n    return urlUtil.toUrlParams(params);\n  },\n  getUrlForPartial,\n  processUrl: (url: string) => {\n    return grafanaConfig.disableSanitizeHtml ? url : textUtil.sanitizeUrl(url);\n  },\n};\n"],"names":[],"mappings":"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"}