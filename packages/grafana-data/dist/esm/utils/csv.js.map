{"version":3,"file":"csv.js","sources":["../../../src/utils/csv.ts"],"sourcesContent":["// Libraries\nimport { defaults } from 'lodash';\nimport Papa, { ParseConfig, Parser, ParseResult } from 'papaparse';\n\n// Types\nimport { MutableDataFrame } from '../dataframe/MutableDataFrame';\nimport { guessFieldTypeFromValue } from '../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../field';\nimport { DataFrame, Field, FieldConfig, FieldType } from '../types';\nimport { formattedValueToString } from '../valueFormats';\n\nexport enum CSVHeaderStyle {\n  full,\n  name,\n  none,\n}\n\n// Subset of all parse options\nexport interface CSVConfig {\n  delimiter?: string; // default: \",\"\n  newline?: string; // default: \"\\r\\n\"\n  quoteChar?: string; // default: '\"'\n  encoding?: string; // default: \"\",\n  useExcelHeader?: boolean; // default: false\n  headerStyle?: CSVHeaderStyle;\n}\n\nexport interface CSVParseCallbacks {\n  /**\n   * Get a callback before any rows are processed\n   * This can return a modified table to force any\n   * Column configurations\n   */\n  onHeader: (fields: Field[]) => void;\n\n  // Called after each row is read\n  onRow: (row: string[]) => void;\n}\n\nexport interface CSVOptions {\n  config?: CSVConfig;\n  callback?: CSVParseCallbacks;\n}\n\nexport function readCSV(csv: string, options?: CSVOptions): DataFrame[] {\n  return new CSVReader(options).readCSV(csv);\n}\n\nenum ParseState {\n  Starting,\n  InHeader,\n  ReadingRows,\n}\n\nexport class CSVReader {\n  config: CSVConfig;\n  callback?: CSVParseCallbacks;\n\n  state: ParseState;\n  data: MutableDataFrame[];\n  current: MutableDataFrame;\n\n  constructor(options?: CSVOptions) {\n    if (!options) {\n      options = {};\n    }\n    this.config = options.config || {};\n    this.callback = options.callback;\n\n    this.current = new MutableDataFrame({ fields: [] });\n    this.state = ParseState.Starting;\n    this.data = [];\n  }\n\n  // PapaParse callback on each line\n  private chunk = (results: ParseResult<string[]>, parser: Parser): void => {\n    for (let i = 0; i < results.data.length; i++) {\n      const line = results.data[i];\n      if (line.length < 1) {\n        continue;\n      }\n      const first = line[0]; // null or value, papaparse does not return ''\n      if (first) {\n        // Comment or header queue\n        if (first.startsWith('#')) {\n          // Look for special header column\n          // #{columkey}#a,b,c\n          const idx = first.indexOf('#', 2);\n          if (idx > 0) {\n            const k = first.slice(1, idx);\n            const isName = 'name' === k;\n\n            // Simple object used to check if headers match\n            const headerKeys: FieldConfig = {\n              unit: '#',\n            };\n\n            // Check if it is a known/supported column\n            if (isName || headerKeys.hasOwnProperty(k)) {\n              // Starting a new table after reading rows\n              if (this.state === ParseState.ReadingRows) {\n                this.current = new MutableDataFrame({ fields: [] });\n                this.data.push(this.current);\n              }\n\n              const v = first.slice(idx + 1);\n              if (isName) {\n                this.current.addFieldFor(undefined, v);\n                for (let j = 1; j < line.length; j++) {\n                  this.current.addFieldFor(undefined, line[j]);\n                }\n              } else {\n                const { fields } = this.current;\n                for (let j = 0; j < fields.length; j++) {\n                  if (!fields[j].config) {\n                    fields[j].config = {};\n                  }\n                  const disp = fields[j].config as any; // any lets name lookup\n                  disp[k] = j === 0 ? v : line[j];\n                }\n              }\n\n              this.state = ParseState.InHeader;\n              continue;\n            }\n          } else if (this.state === ParseState.Starting) {\n            this.state = ParseState.InHeader;\n            continue;\n          }\n          // Ignore comment lines\n          continue;\n        }\n\n        if (this.state === ParseState.Starting) {\n          const type = guessFieldTypeFromValue(first);\n          if (type === FieldType.string) {\n            for (const s of line) {\n              this.current.addFieldFor(undefined, s);\n            }\n            this.state = ParseState.InHeader;\n            continue;\n          }\n          this.state = ParseState.InHeader; // fall through to read rows\n        }\n      }\n\n      // Add the current results to the data\n      if (this.state !== ParseState.ReadingRows) {\n        // anything???\n      }\n\n      this.state = ParseState.ReadingRows;\n\n      // Make sure column structure is valid\n      if (line.length > this.current.fields.length) {\n        const { fields } = this.current;\n        for (let f = fields.length; f < line.length; f++) {\n          this.current.addFieldFor(line[f]);\n        }\n        if (this.callback) {\n          this.callback.onHeader(this.current.fields);\n        }\n      }\n\n      this.current.appendRow(line);\n      if (this.callback) {\n        // // Send the header after we guess the type\n        // if (this.series.rows.length === 0) {\n        //   this.callback.onHeader(this.series);\n        // }\n        this.callback.onRow(line);\n      }\n    }\n  };\n\n  readCSV(text: string): MutableDataFrame[] {\n    this.current = new MutableDataFrame({ fields: [] });\n    this.data = [this.current];\n\n    const papacfg = {\n      ...this.config,\n      dynamicTyping: false,\n      skipEmptyLines: true,\n      comments: false, // Keep comment lines\n      chunk: this.chunk,\n    } as ParseConfig;\n\n    Papa.parse(text, papacfg);\n\n    return this.data;\n  }\n}\n\ntype FieldWriter = (value: unknown) => string;\n\nfunction writeValue(value: unknown, config: CSVConfig): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  const str = value.toString();\n  if (str.includes('\"')) {\n    // Escape the double quote characters\n    return config.quoteChar + str.replace(/\"/gi, '\"\"') + config.quoteChar;\n  }\n  if (str.includes('\\n') || (config.delimiter && str.includes(config.delimiter))) {\n    return config.quoteChar + str + config.quoteChar;\n  }\n  return str;\n}\n\nfunction makeFieldWriter(field: Field, config: CSVConfig): FieldWriter {\n  if (field.display) {\n    return (value: unknown) => {\n      const displayValue = field.display!(value);\n      return writeValue(formattedValueToString(displayValue), config);\n    };\n  }\n\n  return (value: unknown) => writeValue(value, config);\n}\n\nfunction getHeaderLine(key: string, fields: Field[], config: CSVConfig): string {\n  const isName = 'name' === key;\n  const isType = 'type' === key;\n\n  for (const f of fields) {\n    const display = f.config;\n    if (isName || isType || (display && display.hasOwnProperty(key))) {\n      let line = '#' + key + '#';\n      for (let i = 0; i < fields.length; i++) {\n        if (i > 0) {\n          line = line + config.delimiter;\n        }\n\n        let v = fields[i].name;\n        if (isType) {\n          v = fields[i].type;\n        } else if (isName) {\n          // already name\n        } else {\n          v = (fields[i].config as any)[key];\n        }\n        if (v) {\n          line = line + writeValue(v, config);\n        }\n      }\n      return line + config.newline;\n    }\n  }\n  return '';\n}\n\nfunction getLocaleDelimiter(): string {\n  const arr = ['x', 'y'];\n  if (arr.toLocaleString) {\n    return arr.toLocaleString().charAt(1);\n  }\n  return ',';\n}\n\nexport function toCSV(data: DataFrame[], config?: CSVConfig): string {\n  if (!data) {\n    return '';\n  }\n\n  config = defaults(config, {\n    delimiter: getLocaleDelimiter(),\n    newline: '\\r\\n',\n    quoteChar: '\"',\n    encoding: '',\n    headerStyle: CSVHeaderStyle.name,\n    useExcelHeader: false,\n  });\n  let csv = config.useExcelHeader ? `sep=${config.delimiter}${config.newline}` : '';\n\n  for (let s = 0; s < data.length; s++) {\n    const series = data[s];\n    const { fields } = series;\n\n    // ignore frames with no fields\n    if (fields.length === 0) {\n      continue;\n    }\n\n    if (config.headerStyle === CSVHeaderStyle.full) {\n      csv =\n        csv +\n        getHeaderLine('name', fields, config) +\n        getHeaderLine('type', fields, config) +\n        getHeaderLine('unit', fields, config) +\n        getHeaderLine('dateFormat', fields, config);\n    } else if (config.headerStyle === CSVHeaderStyle.name) {\n      for (let i = 0; i < fields.length; i++) {\n        if (i > 0) {\n          csv += config.delimiter;\n        }\n        csv += `\"${getFieldDisplayName(fields[i], series).replace(/\"/g, '\"\"')}\"`;\n      }\n      csv += config.newline;\n    }\n\n    const length = fields[0].values.length;\n\n    if (length > 0) {\n      const writers = fields.map((field) => makeFieldWriter(field, config!));\n      for (let i = 0; i < length; i++) {\n        for (let j = 0; j < fields.length; j++) {\n          if (j > 0) {\n            csv = csv + config.delimiter;\n          }\n\n          const v = fields[j].values[i];\n          if (v !== null) {\n            csv = csv + writers[j](v);\n          }\n        }\n\n        if (i !== length - 1) {\n          csv = csv + config.newline;\n        }\n      }\n    }\n\n    if (s !== data.length - 1) {\n      csv = csv + config.newline;\n    }\n  }\n\n  return csv;\n}\n"],"names":["CSVHeaderStyle"],"mappings":"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"}