{"version":3,"file":"nameMatcher.js","sources":["../../../../src/transformations/matchers/nameMatcher.ts"],"sourcesContent":["import { getFieldDisplayName } from '../../field/fieldState';\nimport { stringToJsRegex } from '../../text/string';\nimport { DataFrame, Field, FieldType, TIME_SERIES_VALUE_FIELD_NAME } from '../../types/dataFrame';\nimport { FieldMatcher, FieldMatcherInfo, FrameMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID, FrameMatcherID } from './ids';\n\nexport interface RegexpOrNamesMatcherOptions {\n  pattern?: string;\n  names?: string[];\n  variable?: string;\n}\n\n/**\n * Mode to be able to toggle if the names matcher should match fields in provided\n * list or all except provided names.\n * @public\n */\nexport enum ByNamesMatcherMode {\n  exclude = 'exclude',\n  include = 'include',\n}\n\n/**\n * Options to instruct the by names matcher to either match all fields in given list\n * or all except the fields in the list.\n * @public\n */\nexport interface ByNamesMatcherOptions {\n  mode?: ByNamesMatcherMode;\n  names?: string[];\n  readOnly?: boolean;\n  prefix?: string;\n}\n\n// General Field matcher\nconst fieldNameMatcher: FieldMatcherInfo<string> = {\n  id: FieldMatcherID.byName,\n  name: 'Field Name',\n  description: 'match the field name',\n  defaultOptions: '',\n\n  get: (name: string): FieldMatcher => {\n    const uniqueNames = new Set<string>([name]);\n\n    const fallback = fieldNameFallback(uniqueNames);\n\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return (\n        name === field.name ||\n        name === getFieldDisplayName(field, frame, allFrames) ||\n        Boolean(fallback && fallback(field, frame, allFrames))\n      );\n    };\n  },\n\n  getOptionsDisplayText: (name: string) => {\n    return `Field name: ${name}`;\n  },\n};\n\nconst multipleFieldNamesMatcher: FieldMatcherInfo<ByNamesMatcherOptions> = {\n  id: FieldMatcherID.byNames,\n  name: 'Field Names',\n  description: 'match any of the given the field names',\n  defaultOptions: {\n    mode: ByNamesMatcherMode.include,\n    names: [],\n  },\n\n  get: (options: ByNamesMatcherOptions): FieldMatcher => {\n    const { names, mode = ByNamesMatcherMode.include } = options;\n    const uniqueNames = new Set<string>(names ?? []);\n\n    const fallback = fieldNameFallback(uniqueNames);\n\n    const matcher = (field: Field, frame: DataFrame, frames: DataFrame[]) => {\n      return (\n        uniqueNames.has(field.name) ||\n        uniqueNames.has(getFieldDisplayName(field, frame, frames)) ||\n        Boolean(fallback && fallback(field, frame, frames))\n      );\n    };\n\n    if (mode === ByNamesMatcherMode.exclude) {\n      return (field: Field, frame: DataFrame, frames: DataFrame[]) => {\n        return !matcher(field, frame, frames);\n      };\n    }\n    return matcher;\n  },\n\n  getOptionsDisplayText: (options: ByNamesMatcherOptions): string => {\n    const { names, mode } = options;\n    const displayText = (names ?? []).join(', ');\n    if (mode === ByNamesMatcherMode.exclude) {\n      return `All except: ${displayText}`;\n    }\n    return `All of: ${displayText}`;\n  },\n};\n\n// In an effort to support migrating to a consistent data contract, the\n// naming conventions need to get normalized. However, many existing setups\n// exist that would no longer match names if that changes.  This injects\n// fallback logic when the data frame has not type version specified\nexport function fieldNameFallback(fields: Set<string>) {\n  let fallback: FieldMatcher | undefined = undefined;\n\n  // grafana-data does not have access to runtime so we are accessing the window object\n  // to get access to the feature toggle\n  // eslint-disable-next-line\n  const useMatcherFallback = (window as any)?.grafanaBootData?.settings?.featureToggles?.dataplaneFrontendFallback;\n  if (useMatcherFallback) {\n    if (fields.has(TIME_SERIES_VALUE_FIELD_NAME)) {\n      fallback = (field: Field, frame: DataFrame) => {\n        return (\n          Boolean(field.labels) && // Value was reasonable when the name was set in labels or on the frame\n          field.labels?.__name__ === field.name\n        );\n      };\n    } else if (fields.has('Time') || fields.has('time')) {\n      fallback = (field: Field, frame: DataFrame) => {\n        return frame.meta?.typeVersion == null && field.type === FieldType.time;\n      };\n    }\n  }\n\n  return fallback;\n}\n\nconst regexpFieldNameMatcher: FieldMatcherInfo<string> = {\n  id: FieldMatcherID.byRegexp,\n  name: 'Field Name by Regexp',\n  description: 'match the field name by a given regexp pattern',\n  defaultOptions: '/.*/',\n\n  get: (pattern: string): FieldMatcher => {\n    const regexp = patternToRegex(pattern);\n\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      const displayName = getFieldDisplayName(field, frame, allFrames);\n      return !!regexp && regexp.test(displayName);\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string): string => {\n    return `Field name by pattern: ${pattern}`;\n  },\n};\n\n/**\n * Field matcher that will match all fields that exists in a\n * data frame with configured refId.\n * @public\n */\nconst fieldsInFrameMatcher: FieldMatcherInfo<string> = {\n  id: FieldMatcherID.byFrameRefID,\n  name: 'Fields by frame refId',\n  description: 'match all fields returned in data frame with refId.',\n  defaultOptions: '',\n\n  get: (refId: string): FieldMatcher => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return frame.refId === refId;\n    };\n  },\n\n  getOptionsDisplayText: (refId: string): string => {\n    return `Math all fields returned by query with reference ID: ${refId}`;\n  },\n};\n\nconst regexpOrMultipleNamesMatcher: FieldMatcherInfo<RegexpOrNamesMatcherOptions> = {\n  id: FieldMatcherID.byRegexpOrNames,\n  name: 'Field Name by Regexp or Names',\n  description: 'match the field name by a given regexp pattern or given names',\n  defaultOptions: {\n    pattern: '/.*/',\n    names: [],\n  },\n\n  get: (options: RegexpOrNamesMatcherOptions): FieldMatcher => {\n    const regexpMatcher = regexpFieldNameMatcher.get(options?.pattern || '');\n    const namesMatcher = multipleFieldNamesMatcher.get({\n      mode: ByNamesMatcherMode.include,\n      names: options?.names ?? [],\n    });\n\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return namesMatcher(field, frame, allFrames) || regexpMatcher(field, frame, allFrames);\n    };\n  },\n\n  getOptionsDisplayText: (options: RegexpOrNamesMatcherOptions): string => {\n    const pattern = options?.pattern ?? '';\n    const names = options?.names?.join(',') ?? '';\n    return `Field name by pattern: ${pattern} or names: ${names}`;\n  },\n};\n\nconst patternToRegex = (pattern?: string): RegExp | undefined => {\n  if (!pattern) {\n    return undefined;\n  }\n\n  try {\n    return stringToJsRegex(pattern);\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n};\n\n// General Frame matcher\nconst frameNameMatcher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byName,\n  name: 'Frame Name',\n  description: 'match the frame name',\n  defaultOptions: '/.*/',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.name || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `Frame name: ${pattern}`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldNameMatchers(): FieldMatcherInfo[] {\n  return [\n    fieldNameMatcher,\n    regexpFieldNameMatcher,\n    multipleFieldNamesMatcher,\n    regexpOrMultipleNamesMatcher,\n    fieldsInFrameMatcher,\n  ];\n}\n\nexport function getFrameNameMatchers(): FrameMatcherInfo[] {\n  return [frameNameMatcher];\n}\n"],"names":["ByNamesMatcherMode","_a"],"mappings":"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"}