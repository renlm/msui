{"version":3,"file":"labelsToFields.js","sources":["../../../../src/transformations/transformers/labelsToFields.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../..';\nimport { DataFrame, Field, FieldType, SynchronousDataTransformerInfo } from '../../types';\n\nimport { DataTransformerID } from './ids';\n\nexport enum LabelsToFieldsMode {\n  Columns = 'columns', // default mode\n  Rows = 'rows',\n}\n\nexport interface LabelsToFieldsOptions {\n  mode?: LabelsToFieldsMode;\n\n  /** When empty, this will keep all labels, otherwise it will keep only labels matching the value */\n  keepLabels?: string[];\n\n  /**\n   * When in column mode and if set this will use this label's value as the value field name.\n   */\n  valueLabel?: string;\n}\n\nexport const labelsToFieldsTransformer: SynchronousDataTransformerInfo<LabelsToFieldsOptions> = {\n  id: DataTransformerID.labelsToFields,\n  name: 'Labels to fields',\n  description: 'Extract time series labels to fields (columns or rows)',\n  defaultOptions: {},\n\n  operator: (options, ctx) => (source) =>\n    source.pipe(map((data) => labelsToFieldsTransformer.transformer(options, ctx)(data))),\n\n  transformer: (options: LabelsToFieldsOptions) => (data: DataFrame[]) => {\n    // Show each label as a field row\n    if (options.mode === LabelsToFieldsMode.Rows) {\n      return convertLabelsToRows(data, options.keepLabels);\n    }\n\n    const result: DataFrame[] = [];\n    const keepLabels = options.keepLabels?.length ? new Set(options.keepLabels) : undefined;\n\n    for (const frame of data) {\n      const newFields: Field[] = [];\n      const uniqueLabels: Record<string, Set<string>> = {};\n      for (const field of frame.fields) {\n        if (!field.labels) {\n          newFields.push(field);\n          continue;\n        }\n\n        const sansLabels = {\n          ...field,\n          config: {\n            ...field.config,\n            // we need to clear these for this transform as these can contain label names that we no longer want\n            displayName: undefined,\n            displayNameFromDS: undefined,\n          },\n          labels: undefined,\n        };\n        newFields.push(sansLabels);\n\n        for (const labelName of Object.keys(field.labels)) {\n          if (keepLabels && !keepLabels.has(labelName)) {\n            continue;\n          }\n\n          // if we should use this label as the value field name store it and skip adding this as a separate field\n          if (options.valueLabel === labelName) {\n            sansLabels.name = field.labels[labelName];\n            continue;\n          }\n\n          const uniqueValues = uniqueLabels[labelName] ?? (uniqueLabels[labelName] = new Set()); // (Safari 13.1 lacks ??= support)\n          uniqueValues.add(field.labels[labelName]);\n        }\n      }\n\n      for (const name in uniqueLabels) {\n        for (const value of uniqueLabels[name]) {\n          const values = new Array(frame.length).fill(value);\n          newFields.push({\n            name: name,\n            type: FieldType.string,\n            values: values,\n            config: {},\n          });\n        }\n      }\n\n      result.push({\n        ...frame,\n        fields: newFields,\n        length: frame.length,\n      });\n    }\n\n    return result;\n  },\n};\n\nfunction convertLabelsToRows(data: DataFrame[], keepLabels?: string[]): DataFrame[] {\n  const result: DataFrame[] = [];\n  for (const frame of data) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        const keys: string[] = [];\n        const vals: string[] = [];\n        if (keepLabels) {\n          for (const key of keepLabels) {\n            keys.push(key);\n            vals.push(field.labels[key]);\n          }\n        } else {\n          for (const [key, val] of Object.entries(field.labels)) {\n            keys.push(key);\n            vals.push(val);\n          }\n        }\n        if (vals.length) {\n          result.push({\n            ...frame,\n            name: getFieldDisplayName(field, frame, data),\n            fields: [\n              { name: 'label', type: FieldType.string, config: {}, values: keys },\n              { name: 'value', type: FieldType.string, config: {}, values: vals },\n            ],\n            length: vals.length,\n          });\n        }\n      }\n    }\n  }\n  return result;\n}\n"],"names":[],"mappings":"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"}