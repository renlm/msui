{"version":3,"file":"filterByValue.js","sources":["../../../../src/transformations/transformers/filterByValue.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field } from '../../types/dataFrame';\nimport { DataTransformerInfo, MatcherConfig } from '../../types/transformations';\nimport { getValueMatcher } from '../matchers';\nimport { ValueMatcherID } from '../matchers/ids';\n\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\nimport { transformationsVariableSupport } from './utils';\n\nexport enum FilterByValueType {\n  exclude = 'exclude',\n  include = 'include',\n}\n\nexport enum FilterByValueMatch {\n  all = 'all',\n  any = 'any',\n}\n\nexport interface FilterByValueFilter {\n  fieldName: string;\n  config: MatcherConfig;\n}\n\nexport interface FilterByValueTransformerOptions {\n  filters: FilterByValueFilter[];\n  type: FilterByValueType;\n  match: FilterByValueMatch;\n}\n\nexport const filterByValueTransformer: DataTransformerInfo<FilterByValueTransformerOptions> = {\n  id: DataTransformerID.filterByValue,\n  name: 'Filter data by values',\n  description: 'select a subset of results based on values',\n  defaultOptions: {\n    filters: [],\n    type: FilterByValueType.include,\n    match: FilterByValueMatch.any,\n  },\n\n  operator: (options, ctx) => (source) => {\n    const filters = options.filters;\n    const matchAll = options.match === FilterByValueMatch.all;\n    const include = options.type === FilterByValueType.include;\n\n    if (!Array.isArray(filters) || filters.length === 0) {\n      return source.pipe(noopTransformer.operator({}, ctx));\n    }\n\n    const interpolatedFilters: FilterByValueFilter[] = [];\n\n    if (transformationsVariableSupport()) {\n      interpolatedFilters.push(\n        ...filters.map((filter) => {\n          if (filter.config.id === ValueMatcherID.between) {\n            const interpolatedFrom = ctx.interpolate(filter.config.options.from);\n            const interpolatedTo = ctx.interpolate(filter.config.options.to);\n\n            const newFilter = {\n              ...filter,\n              config: {\n                ...filter.config,\n                options: {\n                  ...filter.config.options,\n                  to: interpolatedTo,\n                  from: interpolatedFrom,\n                },\n              },\n            };\n\n            return newFilter;\n          } else if (filter.config.id === ValueMatcherID.regex) {\n            // Due to colliding syntaxes, interpolating regex filters will cause issues.\n            return filter;\n          } else if (filter.config.options.value) {\n            const interpolatedValue = ctx.interpolate(filter.config.options.value);\n            const newFilter = {\n              ...filter,\n              config: { ...filter.config, options: { ...filter.config.options, value: interpolatedValue } },\n            };\n            newFilter.config.options.value! = interpolatedValue;\n            return newFilter;\n          }\n\n          return filter;\n        })\n      );\n    }\n\n    return source.pipe(\n      map((data) => {\n        if (data.length === 0) {\n          return data;\n        }\n\n        const processed: DataFrame[] = [];\n\n        const fieldIndexByName = groupFieldIndexByName(data);\n\n        for (const frame of data) {\n          const rows = new Set<number>();\n\n          let matchers;\n          if (transformationsVariableSupport()) {\n            matchers = createFilterValueMatchers(interpolatedFilters, fieldIndexByName);\n          } else {\n            matchers = createFilterValueMatchers(filters, fieldIndexByName);\n          }\n\n          for (let index = 0; index < frame.length; index++) {\n            if (rows.has(index)) {\n              continue;\n            }\n\n            let matching = true;\n\n            for (const matcher of matchers) {\n              const match = matcher(index, frame, data);\n\n              if (!matchAll && match) {\n                matching = true;\n                break;\n              }\n\n              if (matchAll && !match) {\n                matching = false;\n                break;\n              }\n\n              matching = match;\n            }\n\n            if (matching) {\n              rows.add(index);\n            }\n          }\n\n          const fields: Field[] = [];\n          const frameLength = include ? rows.size : data[0].length - rows.size;\n\n          for (const field of frame.fields) {\n            const buffer = [];\n\n            for (let index = 0; index < frame.length; index++) {\n              if (include && rows.has(index)) {\n                buffer.push(field.values[index]);\n                continue;\n              }\n\n              if (!include && !rows.has(index)) {\n                buffer.push(field.values[index]);\n                continue;\n              }\n            }\n\n            // We keep field config, but clean the state as it's being recalculated when the field overrides are applied\n            fields.push({\n              ...field,\n              values: buffer,\n              state: {},\n            });\n          }\n\n          processed.push({\n            ...frame,\n            fields: fields,\n            length: frameLength,\n          });\n        }\n\n        return processed;\n      })\n    );\n  },\n};\n\nconst createFilterValueMatchers = (\n  filters: FilterByValueFilter[],\n  fieldIndexByName: Record<string, number>\n): Array<(index: number, frame: DataFrame, data: DataFrame[]) => boolean> => {\n  const noop = () => false;\n\n  return filters.map((filter) => {\n    const fieldIndex = fieldIndexByName[filter.fieldName] ?? -1;\n\n    if (fieldIndex < 0) {\n      console.warn(`[FilterByValue] Could not find index for field name: ${filter.fieldName}`);\n      return noop;\n    }\n\n    const matcher = getValueMatcher(filter.config);\n    return (index, frame, data) => matcher(index, frame.fields[fieldIndex], frame, data);\n  });\n};\n\nconst groupFieldIndexByName = (data: DataFrame[]) => {\n  const lookup: Record<string, number> = {};\n\n  for (const frame of data) {\n    frame.fields.forEach((field, fieldIndex) => {\n      const fieldName = getFieldDisplayName(field, frame, data);\n      lookup[fieldName] = fieldIndex;\n    });\n  }\n\n  return lookup;\n};\n"],"names":[],"mappings":"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"}