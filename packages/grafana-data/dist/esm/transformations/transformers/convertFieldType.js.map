{"version":3,"file":"convertFieldType.js","sources":["../../../../src/transformations/transformers/convertFieldType.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { TimeZone } from '@grafana/schema';\n\nimport { DateTimeOptionsWhenParsing, dateTimeParse } from '../../datetime';\nimport { SynchronousDataTransformerInfo } from '../../types';\nimport { DataFrame, EnumFieldConfig, Field, FieldType } from '../../types/dataFrame';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { DataTransformerID } from './ids';\n\nexport interface ConvertFieldTypeTransformerOptions {\n  conversions: ConvertFieldTypeOptions[];\n}\n\nexport interface ConvertFieldTypeOptions {\n  /**\n   * The field to convert field type\n   */\n  targetField?: string;\n  /**\n   * The field type to convert to\n   */\n  destinationType?: FieldType;\n  /**\n   * Date format to parse a string datetime\n   */\n  dateFormat?: string;\n  /**\n   * When converting an array to a string, the values can be joined with a custom separator\n   */\n  joinWith?: string;\n  /**\n   * When converting a date to a string an option timezone.\n   */\n  timezone?: TimeZone;\n  /**\n   * When converting to an enumeration, this is the target config\n   */\n  enumConfig?: EnumFieldConfig;\n}\n\nexport const convertFieldTypeTransformer: SynchronousDataTransformerInfo<ConvertFieldTypeTransformerOptions> = {\n  id: DataTransformerID.convertFieldType,\n  name: 'Convert field type',\n  description: 'Convert a field to a specified field type.',\n  defaultOptions: {\n    fields: {},\n    conversions: [{ targetField: undefined, destinationType: undefined, dateFormat: undefined, timezone: undefined }],\n  },\n\n  operator: (options, ctx) => (source) =>\n    source.pipe(map((data) => convertFieldTypeTransformer.transformer(options, ctx)(data))),\n\n  transformer: (options: ConvertFieldTypeTransformerOptions) => (data: DataFrame[]) => {\n    if (!Array.isArray(data) || data.length === 0) {\n      return data;\n    }\n    return convertFieldTypes(options, data) ?? [];\n  },\n};\n\n/**\n * Convert field types for dataframe(s)\n * @param options - field type conversion options\n * @param frames - dataframe(s) with field types to convert\n * @returns dataframe(s) with converted field types\n */\nexport function convertFieldTypes(options: ConvertFieldTypeTransformerOptions, frames: DataFrame[]): DataFrame[] {\n  if (!options.conversions.length) {\n    return frames;\n  }\n\n  const framesCopy = frames.map((frame) => ({ ...frame }));\n\n  for (const conversion of options.conversions) {\n    if (!conversion.targetField) {\n      continue;\n    }\n    const matches = fieldMatchers.get(FieldMatcherID.byName).get(conversion.targetField);\n    for (const frame of framesCopy) {\n      frame.fields = frame.fields.map((field) => {\n        if (matches(field, frame, framesCopy)) {\n          return convertFieldType(field, conversion);\n        }\n        return field;\n      });\n    }\n  }\n\n  return framesCopy;\n}\n\n/**\n * Convert a single field type to specified field type.\n * @param field - field to convert\n * @param opts - field conversion options\n * @returns converted field\n *\n * @internal\n */\nexport function convertFieldType(field: Field, opts: ConvertFieldTypeOptions): Field {\n  switch (opts.destinationType) {\n    case FieldType.time:\n      return ensureTimeField(field, opts.dateFormat);\n    case FieldType.number:\n      return fieldToNumberField(field);\n    case FieldType.string:\n      return fieldToStringField(field, opts.dateFormat, { timeZone: opts.timezone }, opts.joinWith);\n    case FieldType.boolean:\n      return fieldToBooleanField(field);\n    case FieldType.enum:\n      return fieldToEnumField(field, opts.enumConfig);\n    case FieldType.other:\n      return fieldToComplexField(field);\n    default:\n      return field;\n  }\n}\n\n// matches common ISO 8601 (see tests)\nconst iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3,})?(?:Z|[-+]\\d{2}:?\\d{2})$/;\n\n/**\n * @internal\n */\nexport function fieldToTimeField(field: Field, dateFormat?: string): Field {\n  let opts = dateFormat ? { format: dateFormat } : undefined;\n\n  const timeValues = field.values.slice();\n\n  let firstDefined = timeValues.find((v) => v != null);\n\n  let isISO8601 = typeof firstDefined === 'string' && iso8601Regex.test(firstDefined);\n\n  for (let t = 0; t < timeValues.length; t++) {\n    if (timeValues[t]) {\n      let parsed = isISO8601 ? Date.parse(timeValues[t]) : dateTimeParse(timeValues[t], opts).valueOf();\n      timeValues[t] = Number.isFinite(parsed) ? parsed : null;\n    } else {\n      timeValues[t] = null;\n    }\n  }\n\n  return {\n    ...field,\n    type: FieldType.time,\n    values: timeValues,\n  };\n}\n\nfunction fieldToNumberField(field: Field): Field {\n  const numValues = field.values.slice();\n\n  const valuesAsStrings = numValues.some((v) => typeof v === 'string');\n\n  for (let n = 0; n < numValues.length; n++) {\n    let toBeConverted = numValues[n];\n\n    if (valuesAsStrings && toBeConverted != null && typeof toBeConverted === 'string') {\n      // some numbers returned from datasources have commas\n      // strip the commas, coerce the string to a number\n      toBeConverted = toBeConverted.replace(/,/g, '');\n    }\n\n    const number = +toBeConverted;\n\n    numValues[n] = Number.isFinite(number) ? number : null;\n  }\n\n  return {\n    ...field,\n    type: FieldType.number,\n    values: numValues,\n  };\n}\n\nfunction fieldToBooleanField(field: Field): Field {\n  const booleanValues = field.values.slice();\n\n  for (let b = 0; b < booleanValues.length; b++) {\n    booleanValues[b] = Boolean(!!booleanValues[b]);\n  }\n\n  return {\n    ...field,\n    type: FieldType.boolean,\n    values: booleanValues,\n  };\n}\n\n/**\n * @internal\n */\nexport function fieldToStringField(\n  field: Field,\n  dateFormat?: string,\n  parseOptions?: DateTimeOptionsWhenParsing,\n  joinWith?: string\n): Field {\n  let values = field.values;\n\n  switch (field.type) {\n    case FieldType.time:\n      values = values.map((v) => dateTimeParse(v, parseOptions).format(dateFormat));\n      break;\n\n    case FieldType.other:\n      values = values.map((v) => {\n        if (joinWith?.length && Array.isArray(v)) {\n          return v.join(joinWith);\n        }\n        return JSON.stringify(v); // will quote strings and avoid \"object\"\n      });\n      break;\n\n    default:\n      values = values.map((v) => `${v}`);\n  }\n\n  return {\n    ...field,\n    type: FieldType.string,\n    values: values,\n  };\n}\n\nfunction fieldToComplexField(field: Field): Field {\n  const complexValues = field.values.slice();\n\n  for (let s = 0; s < complexValues.length; s++) {\n    try {\n      complexValues[s] = JSON.parse(complexValues[s]);\n    } catch {\n      complexValues[s] = null;\n    }\n  }\n\n  return {\n    ...field,\n    type: FieldType.other,\n    values: complexValues,\n  };\n}\n\n/**\n * Checks the first value. Assumes any number should be time fieldtype. Otherwise attempts to make the fieldtype time.\n * @param field - field to ensure is a time fieldtype\n * @param dateFormat - date format used to parse a string datetime\n * @returns field as time\n *\n * @public\n */\nexport function ensureTimeField(field: Field, dateFormat?: string): Field {\n  const firstValueTypeIsNumber = typeof field.values[0] === 'number';\n  if (field.type === FieldType.time && firstValueTypeIsNumber) {\n    return field; //already time\n  }\n  if (firstValueTypeIsNumber) {\n    return {\n      ...field,\n      type: FieldType.time, //assumes it should be time\n    };\n  }\n  return fieldToTimeField(field, dateFormat);\n}\n\nfunction fieldToEnumField(field: Field, config?: EnumFieldConfig): Field {\n  const enumConfig = { ...config };\n  const enumValues = field.values.slice();\n\n  // Create lookup map based on existing enum config text values, if none exist return field as is\n  const lookup = new Map<unknown, number>();\n  if (enumConfig.text && enumConfig.text.length > 0) {\n    for (let i = 0; i < enumConfig.text.length; i++) {\n      lookup.set(enumConfig.text[i], i);\n    }\n  } else {\n    return field;\n  }\n\n  // Convert field values to enum indexes\n  for (let i = 0; i < enumValues.length; i++) {\n    const value = enumValues[i];\n    enumValues[i] = lookup.get(value);\n  }\n\n  return {\n    ...field,\n    config: {\n      ...field.config,\n      type: {\n        enum: enumConfig,\n      },\n    },\n    type: FieldType.enum,\n    values: enumValues,\n  };\n}\n"],"names":[],"mappings":"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"}