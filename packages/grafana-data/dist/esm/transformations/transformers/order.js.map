{"version":3,"file":"order.js","sources":["../../../../src/transformations/transformers/order.ts"],"sourcesContent":["import { clone } from 'lodash';\nimport { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field } from '../../types';\nimport { DataTransformerInfo } from '../../types/transformations';\n\nimport { DataTransformerID } from './ids';\n\nexport interface OrderFieldsTransformerOptions {\n  indexByName: Record<string, number>;\n}\n\nexport const orderFieldsTransformer: DataTransformerInfo<OrderFieldsTransformerOptions> = {\n  id: DataTransformerID.order,\n  name: 'Order fields by name',\n  description: 'Order fields based on configuration given by user',\n  defaultOptions: {\n    indexByName: {},\n  },\n\n  /**\n   * Return a modified copy of the series. If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        const orderer = createFieldsOrderer(options.indexByName);\n\n        if (!Array.isArray(data) || data.length === 0) {\n          return data;\n        }\n\n        return data.map((frame) => ({\n          ...frame,\n          fields: orderer(frame.fields, data, frame),\n        }));\n      })\n    ),\n};\n\nexport const createOrderFieldsComparer = (indexByName: Record<string, number>) => (a: string, b: string) => {\n  return indexOfField(a, indexByName) - indexOfField(b, indexByName);\n};\n\nconst createFieldsOrderer =\n  (indexByName: Record<string, number>) => (fields: Field[], data: DataFrame[], frame: DataFrame) => {\n    if (!Array.isArray(fields) || fields.length === 0) {\n      return fields;\n    }\n    if (!indexByName || Object.keys(indexByName).length === 0) {\n      return fields;\n    }\n    const comparer = createOrderFieldsComparer(indexByName);\n    return clone(fields).sort((a, b) =>\n      comparer(getFieldDisplayName(a, frame, data), getFieldDisplayName(b, frame, data))\n    );\n  };\n\nconst indexOfField = (fieldName: string, indexByName: Record<string, number>) => {\n  if (Number.isInteger(indexByName[fieldName])) {\n    return indexByName[fieldName];\n  }\n  return Number.MAX_SAFE_INTEGER;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAaO,MAAM,sBAA6E,GAAA;AAAA,EACxF,IAAI,iBAAkB,CAAA,KAAA;AAAA,EACtB,IAAM,EAAA,sBAAA;AAAA,EACN,WAAa,EAAA,mDAAA;AAAA,EACb,cAAgB,EAAA;AAAA,IACd,aAAa,EAAC;AAAA,GAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAU,EAAA,CAAC,OAAY,KAAA,CAAC,WACtB,MAAO,CAAA,IAAA;AAAA,IACL,GAAA,CAAI,CAAC,IAAS,KAAA;AACZ,MAAM,MAAA,OAAA,GAAU,mBAAoB,CAAA,OAAA,CAAQ,WAAW,CAAA,CAAA;AAEvD,MAAA,IAAI,CAAC,KAAM,CAAA,OAAA,CAAQ,IAAI,CAAK,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA;AAC7C,QAAO,OAAA,IAAA,CAAA;AAAA,OACT;AAEA,MAAA,OAAO,IAAK,CAAA,GAAA,CAAI,CAAC,KAAA,KAAW,iCACvB,KADuB,CAAA,EAAA;AAAA,QAE1B,MAAQ,EAAA,OAAA,CAAQ,KAAM,CAAA,MAAA,EAAQ,MAAM,KAAK,CAAA;AAAA,OACzC,CAAA,CAAA,CAAA;AAAA,KACH,CAAA;AAAA,GACH;AACJ,EAAA;AAEO,MAAM,yBAA4B,GAAA,CAAC,WAAwC,KAAA,CAAC,GAAW,CAAc,KAAA;AAC1G,EAAA,OAAO,aAAa,CAAG,EAAA,WAAW,CAAI,GAAA,YAAA,CAAa,GAAG,WAAW,CAAA,CAAA;AACnE,EAAA;AAEA,MAAM,sBACJ,CAAC,WAAA,KAAwC,CAAC,MAAA,EAAiB,MAAmB,KAAqB,KAAA;AACjG,EAAA,IAAI,CAAC,KAAM,CAAA,OAAA,CAAQ,MAAM,CAAK,IAAA,MAAA,CAAO,WAAW,CAAG,EAAA;AACjD,IAAO,OAAA,MAAA,CAAA;AAAA,GACT;AACA,EAAA,IAAI,CAAC,WAAe,IAAA,MAAA,CAAO,KAAK,WAAW,CAAA,CAAE,WAAW,CAAG,EAAA;AACzD,IAAO,OAAA,MAAA,CAAA;AAAA,GACT;AACA,EAAM,MAAA,QAAA,GAAW,0BAA0B,WAAW,CAAA,CAAA;AACtD,EAAO,OAAA,KAAA,CAAM,MAAM,CAAE,CAAA,IAAA;AAAA,IAAK,CAAC,CAAA,EAAG,CAC5B,KAAA,QAAA,CAAS,mBAAoB,CAAA,CAAA,EAAG,KAAO,EAAA,IAAI,CAAG,EAAA,mBAAA,CAAoB,CAAG,EAAA,KAAA,EAAO,IAAI,CAAC,CAAA;AAAA,GACnF,CAAA;AACF,CAAA,CAAA;AAEF,MAAM,YAAA,GAAe,CAAC,SAAA,EAAmB,WAAwC,KAAA;AAC/E,EAAA,IAAI,MAAO,CAAA,SAAA,CAAU,WAAY,CAAA,SAAS,CAAC,CAAG,EAAA;AAC5C,IAAA,OAAO,YAAY,SAAS,CAAA,CAAA;AAAA,GAC9B;AACA,EAAA,OAAO,MAAO,CAAA,gBAAA,CAAA;AAChB,CAAA;;;;"}