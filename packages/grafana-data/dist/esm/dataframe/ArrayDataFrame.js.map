{"version":3,"file":"ArrayDataFrame.js","sources":["../../../src/dataframe/ArrayDataFrame.ts"],"sourcesContent":["import { QueryResultMeta } from '../types';\nimport { Field, FieldType, DataFrame, TIME_SERIES_VALUE_FIELD_NAME } from '../types/dataFrame';\n\nimport { guessFieldTypeForField } from './processDataFrame';\n\n/**\n * The ArrayDataFrame takes an array of objects and presents it as a DataFrame\n *\n * @deprecated use arrayToDataFrame\n */\nexport class ArrayDataFrame<T = any> implements DataFrame {\n  fields: Field[] = [];\n  length = 0;\n  name?: string;\n  refId?: string;\n  meta?: QueryResultMeta;\n\n  constructor(source: T[], names?: string[]) {\n    return arrayToDataFrame(source, names); // returns a standard DataFrame\n  }\n}\n\n/**\n * arrayToDataFrame will convert any array into a DataFrame.\n * @param source - can be an array of objects or an array of simple values.\n * @param names - will be used for ordering of fields. Source needs to be array of objects if names are provided.\n *\n * @public\n */\nexport function arrayToDataFrame(source: Array<Record<string, unknown>> | unknown[], names?: string[]): DataFrame {\n  const df: DataFrame = {\n    fields: [],\n    length: source.length,\n  };\n  if (!source?.length) {\n    return df;\n  }\n\n  // If names are provided then we assume the source is an array of objects with the names as keys (field names). This\n  // makes ordering of the fields predictable.\n  if (names) {\n    if (!isObjectArray(source)) {\n      throw new Error('source is not an array of objects');\n    }\n\n    for (const name of names) {\n      df.fields.push(\n        makeFieldFromValues(\n          name,\n          source.map((v) => (v ? v[name] : v))\n        )\n      );\n    }\n    return df;\n  }\n\n  const firstDefined = source.find((v) => v); // first not null|undefined\n  // This means if the source is lots of null/undefined values we throw that away and return empty dataFrame. This is\n  // different to how we preserve null/undefined values if there is some defined rows. Not sure this inconsistency\n  // is by design or not.\n  if (firstDefined === null) {\n    return df;\n  }\n\n  // If is an array of objects we use the keys as field names.\n  if (isObjectArray(source)) {\n    // We need to do this to please TS. We know source is array of objects and that there is some object in there but\n    // TS still thinks it can all be undefined|nulls.\n    const first = source.find((v) => v);\n    df.fields = Object.keys(first || {}).map((name) => {\n      return makeFieldFromValues(\n        name,\n        source.map((v) => (v ? v[name] : v))\n      );\n    });\n  } else {\n    // Otherwise source should be an array of simple values, so we create single field data frame.\n    df.fields.push(makeFieldFromValues(TIME_SERIES_VALUE_FIELD_NAME, source));\n  }\n  return df;\n}\n\nfunction makeFieldFromValues(name: string, values: unknown[]): Field {\n  const f = { name, config: {}, values, type: FieldType.other };\n  f.type = guessFieldTypeForField(f) ?? FieldType.other;\n  return f;\n}\n\nfunction isObjectArray(arr: unknown[]): arr is Array<Record<string, unknown> | null | undefined> {\n  const first = arr.find((v) => v); // first not null|undefined\n  return arr.length > 0 && typeof first === 'object';\n}\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,cAA6C,CAAA;AAAA,EAOxD,WAAA,CAAY,QAAa,KAAkB,EAAA;AAN3C,IAAA,aAAA,CAAA,IAAA,EAAA,QAAA,EAAkB,EAAC,CAAA,CAAA;AACnB,IAAS,aAAA,CAAA,IAAA,EAAA,QAAA,EAAA,CAAA,CAAA,CAAA;AACT,IAAA,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAGE,IAAO,OAAA,gBAAA,CAAiB,QAAQ,KAAK,CAAA,CAAA;AAAA,GACvC;AACF,CAAA;AASgB,SAAA,gBAAA,CAAiB,QAAoD,KAA6B,EAAA;AAChH,EAAA,MAAM,EAAgB,GAAA;AAAA,IACpB,QAAQ,EAAC;AAAA,IACT,QAAQ,MAAO,CAAA,MAAA;AAAA,GACjB,CAAA;AACA,EAAI,IAAA,EAAC,iCAAQ,MAAQ,CAAA,EAAA;AACnB,IAAO,OAAA,EAAA,CAAA;AAAA,GACT;AAIA,EAAA,IAAI,KAAO,EAAA;AACT,IAAI,IAAA,CAAC,aAAc,CAAA,MAAM,CAAG,EAAA;AAC1B,MAAM,MAAA,IAAI,MAAM,mCAAmC,CAAA,CAAA;AAAA,KACrD;AAEA,IAAA,KAAA,MAAW,QAAQ,KAAO,EAAA;AACxB,MAAA,EAAA,CAAG,MAAO,CAAA,IAAA;AAAA,QACR,mBAAA;AAAA,UACE,IAAA;AAAA,UACA,MAAA,CAAO,IAAI,CAAC,CAAA,KAAO,IAAI,CAAE,CAAA,IAAI,IAAI,CAAE,CAAA;AAAA,SACrC;AAAA,OACF,CAAA;AAAA,KACF;AACA,IAAO,OAAA,EAAA,CAAA;AAAA,GACT;AAEA,EAAA,MAAM,YAAe,GAAA,MAAA,CAAO,IAAK,CAAA,CAAC,MAAM,CAAC,CAAA,CAAA;AAIzC,EAAA,IAAI,iBAAiB,IAAM,EAAA;AACzB,IAAO,OAAA,EAAA,CAAA;AAAA,GACT;AAGA,EAAI,IAAA,aAAA,CAAc,MAAM,CAAG,EAAA;AAGzB,IAAA,MAAM,KAAQ,GAAA,MAAA,CAAO,IAAK,CAAA,CAAC,MAAM,CAAC,CAAA,CAAA;AAClC,IAAG,EAAA,CAAA,MAAA,GAAS,OAAO,IAAK,CAAA,KAAA,IAAS,EAAE,CAAA,CAAE,GAAI,CAAA,CAAC,IAAS,KAAA;AACjD,MAAO,OAAA,mBAAA;AAAA,QACL,IAAA;AAAA,QACA,MAAA,CAAO,IAAI,CAAC,CAAA,KAAO,IAAI,CAAE,CAAA,IAAI,IAAI,CAAE,CAAA;AAAA,OACrC,CAAA;AAAA,KACD,CAAA,CAAA;AAAA,GACI,MAAA;AAEL,IAAA,EAAA,CAAG,MAAO,CAAA,IAAA,CAAK,mBAAoB,CAAA,4BAAA,EAA8B,MAAM,CAAC,CAAA,CAAA;AAAA,GAC1E;AACA,EAAO,OAAA,EAAA,CAAA;AACT,CAAA;AAEA,SAAS,mBAAA,CAAoB,MAAc,MAA0B,EAAA;AAlFrE,EAAA,IAAA,EAAA,CAAA;AAmFE,EAAM,MAAA,CAAA,GAAI,EAAE,IAAM,EAAA,MAAA,EAAQ,EAAI,EAAA,MAAA,EAAQ,IAAM,EAAA,SAAA,CAAU,KAAM,EAAA,CAAA;AAC5D,EAAA,CAAA,CAAE,IAAO,GAAA,CAAA,EAAA,GAAA,sBAAA,CAAuB,CAAC,CAAA,KAAxB,YAA6B,SAAU,CAAA,KAAA,CAAA;AAChD,EAAO,OAAA,CAAA,CAAA;AACT,CAAA;AAEA,SAAS,cAAc,GAA0E,EAAA;AAC/F,EAAA,MAAM,KAAQ,GAAA,GAAA,CAAI,IAAK,CAAA,CAAC,MAAM,CAAC,CAAA,CAAA;AAC/B,EAAA,OAAO,GAAI,CAAA,MAAA,GAAS,CAAK,IAAA,OAAO,KAAU,KAAA,QAAA,CAAA;AAC5C;;;;"}