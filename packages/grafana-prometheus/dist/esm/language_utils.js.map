{"version":3,"file":"language_utils.js","sources":["../../src/language_utils.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/language_utils.ts\nimport { invert } from 'lodash';\nimport { Token } from 'prismjs';\n\nimport {\n  AbstractLabelMatcher,\n  AbstractLabelOperator,\n  AbstractQuery,\n  DataQuery,\n  dateMath,\n  DateTime,\n  incrRoundDn,\n  TimeRange,\n} from '@grafana/data';\n\nimport { addLabelToQuery } from './add_label_to_query';\nimport { SUGGESTIONS_LIMIT } from './language_provider';\nimport { PROMETHEUS_QUERY_BUILDER_MAX_RESULTS } from './querybuilder/components/MetricSelect';\nimport { PrometheusCacheLevel, PromMetricsMetadata, PromMetricsMetadataItem } from './types';\n\nexport const processHistogramMetrics = (metrics: string[]) => {\n  const resultSet: Set<string> = new Set();\n  const regexp = new RegExp('_bucket($|:)');\n  for (let index = 0; index < metrics.length; index++) {\n    const metric = metrics[index];\n    const isHistogramValue = regexp.test(metric);\n    if (isHistogramValue) {\n      resultSet.add(metric);\n    }\n  }\n  return [...resultSet];\n};\n\nexport function processLabels(labels: Array<{ [key: string]: string }>, withName = false) {\n  // For processing we are going to use sets as they have significantly better performance than arrays\n  // After we process labels, we will convert sets to arrays and return object with label values in arrays\n  const valueSet: { [key: string]: Set<string> } = {};\n  labels.forEach((label) => {\n    const { __name__, ...rest } = label;\n    if (withName) {\n      valueSet['__name__'] = valueSet['__name__'] || new Set();\n      if (!valueSet['__name__'].has(__name__)) {\n        valueSet['__name__'].add(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach((key) => {\n      if (!valueSet[key]) {\n        valueSet[key] = new Set();\n      }\n      if (!valueSet[key].has(rest[key])) {\n        valueSet[key].add(rest[key]);\n      }\n    });\n  });\n\n  // valueArray that we are going to return in the object\n  const valueArray: { [key: string]: string[] } = {};\n  limitSuggestions(Object.keys(valueSet)).forEach((key) => {\n    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));\n  });\n\n  return { values: valueArray, keys: Object.keys(valueArray) };\n}\n\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\nexport const selectorRegexp = /\\{[^}]*?(\\}|$)/;\n\n// This will capture 4 groups. Example label filter => {instance=\"10.4.11.4:9003\"}\n// 1. label:    instance\n// 2. operator: =\n// 3. value:    \"10.4.11.4:9003\"\n// 4. comma:    if there is a comma it will give ,\n// 5. space:    if there is a space after comma it will give the whole space\n// comma and space is useful for addLabelsToExpression function\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")(,)?(\\s*)?/g;\n\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: string[]; selector: string } {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__'],\n      };\n    }\n    throw new Error('Query must contain a selector: ' + query);\n  }\n\n  // Check if inside a selector\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  }\n\n  // Extract clean labels to form clean selector, incomplete labels are dropped\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels: { [key: string]: { value: string; operator: string } } = {};\n  selector.replace(labelRegexp, (label, key, operator, value) => {\n    const labelOffset = query.indexOf(label);\n    const valueStart = labelOffset + key.length + operator.length + 1;\n    const valueEnd = labelOffset + key.length + operator.length + value.length - 1;\n    // Skip label if cursor is in value\n    if (cursorOffset < valueStart || cursorOffset > valueEnd) {\n      labels[key] = { value, operator };\n    }\n    return '';\n  });\n\n  // Add metric if there is one before the selector\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n  if (metricMatch) {\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\n  }\n\n  // Build sorted selector\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map((key) => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n\n  const selectorString = ['{', cleanSelector, '}'].join('');\n\n  return { labelKeys, selector: selectorString };\n}\n\nexport function expandRecordingRules(query: string, mapping: { [name: string]: string }): string {\n  const getRuleRegex = (ruleName: string) => new RegExp(`(\\\\s|\\\\(|^)(${ruleName})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n\n  // For each mapping key we iterate over the query and split them in parts.\n  // recording:rule{label=~\"/label/value\"} * some:other:rule{other_label=\"value\"}\n  // We want to keep parts in here like this:\n  // recording:rule\n  // {label=~\"/label/value\"} *\n  // some:other:rule\n  // {other_label=\"value\"}\n  const tmpSplitParts = Object.keys(mapping).reduce<string[]>(\n    (prev, curr) => {\n      let parts: string[] = [];\n      let tmpParts: string[] = [];\n      let removeIdx: number[] = [];\n\n      // we iterate over prev because it might be like this after first loop\n      // recording:rule and {label=~\"/label/value\"} * some:other:rule{other_label=\"value\"}\n      // so we need to split the second part too\n      prev.filter(Boolean).forEach((p, i) => {\n        const doesMatch = p.match(getRuleRegex(curr));\n        if (doesMatch) {\n          parts = p.split(curr);\n          if (parts.length === 2) {\n            // this is the case when we have such result for this query\n            // max (metric{label=\"value\"})\n            // \"max(\", \"{label=\"value\"}\"\n            removeIdx.push(i);\n            tmpParts.push(...[parts[0], curr, parts[1]].filter(Boolean));\n          } else if (parts.length > 2) {\n            // this is the case when we have such query\n            // metric + metric\n            // when we split it we have such data\n            // \"\", \" + \", \"\"\n            removeIdx.push(i);\n            parts = parts.map((p) => (p === '' ? curr : p));\n            tmpParts.push(...parts);\n          }\n        }\n      });\n\n      // if we have idx to remove that means we split the value in that index.\n      // No need to keep it. Have the new split values instead.\n      removeIdx.forEach((ri) => (prev[ri] = ''));\n      prev = prev.filter(Boolean);\n      prev.push(...tmpParts);\n\n      return prev;\n    },\n    [query]\n  );\n\n  // we have the separate parts. we need to replace the metric and apply the labels if there is any\n  let labelFound = false;\n  const trulyExpandedQuery = tmpSplitParts.map((tsp, i) => {\n    // if we know this loop tsp is a label, not the metric we want to expand\n    if (labelFound) {\n      labelFound = false;\n      return '';\n    }\n\n    // check if the mapping is there\n    if (mapping[tsp]) {\n      const recordingRule = mapping[tsp];\n      // it is a recording rule. if the following is a label then apply it\n      if (i + 1 !== tmpSplitParts.length && tmpSplitParts[i + 1].match(labelRegexp)) {\n        // the next value in the loop is label. Let's apply labels to the metric\n        labelFound = true;\n        const labels = tmpSplitParts[i + 1];\n        const invalidLabelsRegex = /(\\)\\{|\\}\\{|\\]\\{)/;\n        return addLabelsToExpression(recordingRule + labels, invalidLabelsRegex);\n      } else {\n        // it is not a recording rule and might be a binary operation in between two recording rules\n        // So no need to do anything. just return it.\n        return recordingRule;\n      }\n    }\n\n    return tsp;\n  });\n\n  // Remove empty strings and merge them\n  return trulyExpandedQuery.filter(Boolean).join('');\n}\n\nfunction addLabelsToExpression(expr: string, invalidLabelsRegexp: RegExp) {\n  const match = expr.match(invalidLabelsRegexp);\n  if (!match) {\n    return expr;\n  }\n\n  // Split query into 2 parts - before the invalidLabelsRegex match and after.\n  const indexOfRegexMatch = match.index ?? 0;\n  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);\n  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1);\n\n  // Create arrayOfLabelObjects with label objects that have key, operator and value.\n  const arrayOfLabelObjects: Array<{\n    key: string;\n    operator: string;\n    value: string;\n    comma?: string;\n    space?: string;\n  }> = [];\n  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value, comma, space) => {\n    arrayOfLabelObjects.push({ key, operator, value, comma, space });\n    return '';\n  });\n\n  // Loop through all label objects and add them to query.\n  // As a starting point we have valid query without the labels.\n  let result = exprBeforeRegexMatch;\n  arrayOfLabelObjects.filter(Boolean).forEach((obj) => {\n    // Remove extra set of quotes from obj.value\n    const value = obj.value.slice(1, -1);\n    result = addLabelToQuery(result, obj.key, value, obj.operator);\n  });\n\n  // reconstruct the labels\n  let existingLabel = arrayOfLabelObjects.reduce((prev, curr) => {\n    prev += `${curr.key}${curr.operator}${curr.value}${curr.comma ?? ''}${curr.space ?? ''}`;\n    return prev;\n  }, '');\n\n  // Check if there is anything besides labels\n  // Useful for this kind of metrics sum (recording_rule_metric{label1=\"value1\"}) by (env)\n  // if we don't check this part, ) by (env) part will be lost\n  existingLabel = '{' + existingLabel + '}';\n  const potentialLeftOver = exprAfterRegexMatch.replace(existingLabel, '');\n\n  return result + potentialLeftOver;\n}\n\n/**\n * Adds metadata for synthetic metrics for which the API does not provide metadata.\n * See https://github.com/grafana/grafana/issues/22337 for details.\n *\n * @param metadata HELP and TYPE metadata from /api/v1/metadata\n */\nexport function fixSummariesMetadata(metadata: { [metric: string]: PromMetricsMetadataItem[] }): PromMetricsMetadata {\n  if (!metadata) {\n    return metadata;\n  }\n  const baseMetadata: PromMetricsMetadata = {};\n  const summaryMetadata: PromMetricsMetadata = {};\n  for (const metric in metadata) {\n    // NOTE: based on prometheus-documentation, we can receive\n    // multiple metadata-entries for the given metric, it seems\n    // it happens when the same metric is on multiple targets\n    // and their help-text differs\n    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)\n    // for now we just use the first entry.\n    const item = metadata[metric][0];\n    baseMetadata[metric] = item;\n\n    if (item.type === 'histogram') {\n      summaryMetadata[`${metric}_bucket`] = {\n        type: 'counter',\n        help: `Cumulative counters for the observation buckets (${item.help})`,\n      };\n      summaryMetadata[`${metric}_count`] = {\n        type: 'counter',\n        help: `Count of events that have been observed for the histogram metric (${item.help})`,\n      };\n      summaryMetadata[`${metric}_sum`] = {\n        type: 'counter',\n        help: `Total sum of all observed values for the histogram metric (${item.help})`,\n      };\n    }\n    if (item.type === 'summary') {\n      summaryMetadata[`${metric}_count`] = {\n        type: 'counter',\n        help: `Count of events that have been observed for the base metric (${item.help})`,\n      };\n      summaryMetadata[`${metric}_sum`] = {\n        type: 'counter',\n        help: `Total sum of all observed values for the base metric (${item.help})`,\n      };\n    }\n  }\n  // Synthetic series\n  const syntheticMetadata: PromMetricsMetadata = {};\n  syntheticMetadata['ALERTS'] = {\n    type: 'counter',\n    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.',\n  };\n\n  return { ...baseMetadata, ...summaryMetadata, ...syntheticMetadata };\n}\n\nexport function roundMsToMin(milliseconds: number): number {\n  return roundSecToMin(milliseconds / 1000);\n}\n\nexport function roundSecToMin(seconds: number): number {\n  return Math.floor(seconds / 60);\n}\n\n// Returns number of minutes rounded up to the nearest nth minute\nexport function roundSecToNextMin(seconds: number, secondsToRound = 1): number {\n  return Math.ceil(seconds / 60) - (Math.ceil(seconds / 60) % secondsToRound);\n}\n\nexport function limitSuggestions(items: string[]) {\n  return items.slice(0, SUGGESTIONS_LIMIT);\n}\n\nexport function addLimitInfo(items: unknown[] | undefined): string {\n  return items && items.length >= SUGGESTIONS_LIMIT ? `, limited to the first ${SUGGESTIONS_LIMIT} received items` : '';\n}\n\n// NOTE: the following 2 exported functions are very similar to the prometheus*Escape\n// functions in datasource.ts, but they are not exactly the same algorithm, and we found\n// no way to reuse one in the another or vice versa.\n\n// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),\n// so every character that matches something in that list has to be escaped.\n// the list of metacharacters is: *+?()|\\.[]{}^$\n// we make a javascript regular expression that matches those characters:\nconst RE2_METACHARACTERS = /[*+?()|\\\\.\\[\\]{}^$]/g;\n\nfunction escapePrometheusRegexp(value: string): string {\n  return value.replace(RE2_METACHARACTERS, '\\\\$&');\n}\n\n// based on the openmetrics-documentation, the 3 symbols we have to handle are:\n// - \\n ... the newline character\n// - \\  ... the backslash character\n// - \"  ... the double-quote character\nexport function escapeLabelValueInExactSelector(labelValue: string): string {\n  return labelValue.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\"');\n}\n\nexport function escapeLabelValueInRegexSelector(labelValue: string): string {\n  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));\n}\n\nconst FromPromLikeMap: Record<string, AbstractLabelOperator> = {\n  '=': AbstractLabelOperator.Equal,\n  '!=': AbstractLabelOperator.NotEqual,\n  '=~': AbstractLabelOperator.EqualRegEx,\n  '!~': AbstractLabelOperator.NotEqualRegEx,\n};\n\nconst ToPromLikeMap: Record<AbstractLabelOperator, string> = invert(FromPromLikeMap) as Record<\n  AbstractLabelOperator,\n  string\n>;\n\nexport function toPromLikeExpr(labelBasedQuery: AbstractQuery): string {\n  const expr = labelBasedQuery.labelMatchers\n    .map((selector: AbstractLabelMatcher) => {\n      const operator = ToPromLikeMap[selector.operator];\n      if (operator) {\n        return `${selector.name}${operator}\"${selector.value}\"`;\n      } else {\n        return '';\n      }\n    })\n    .filter((e: string) => e !== '')\n    .join(', ');\n\n  return expr ? `{${expr}}` : '';\n}\n\nexport function toPromLikeQuery(labelBasedQuery: AbstractQuery): PromLikeQuery {\n  return {\n    refId: labelBasedQuery.refId,\n    expr: toPromLikeExpr(labelBasedQuery),\n    range: true,\n  };\n}\n\nexport interface PromLikeQuery extends DataQuery {\n  expr: string;\n  range: boolean;\n}\n\nfunction getMaybeTokenStringContent(token: Token): string {\n  if (typeof token.content === 'string') {\n    return token.content;\n  }\n\n  return '';\n}\n\nexport function extractLabelMatchers(tokens: Array<string | Token>): AbstractLabelMatcher[] {\n  const labelMatchers: AbstractLabelMatcher[] = [];\n\n  for (const token of tokens) {\n    if (!(token instanceof Token)) {\n      continue;\n    }\n\n    if (token.type === 'context-labels') {\n      let labelKey = '';\n      let labelValue = '';\n      let labelOperator = '';\n\n      const contentTokens = Array.isArray(token.content) ? token.content : [token.content];\n\n      for (let currentToken of contentTokens) {\n        if (typeof currentToken === 'string') {\n          let currentStr: string;\n          currentStr = currentToken;\n          if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {\n            labelOperator = currentStr;\n          }\n        } else if (currentToken instanceof Token) {\n          switch (currentToken.type) {\n            case 'label-key':\n              labelKey = getMaybeTokenStringContent(currentToken);\n              break;\n            case 'label-value':\n              labelValue = getMaybeTokenStringContent(currentToken);\n              labelValue = labelValue.substring(1, labelValue.length - 1);\n              const labelComparator = FromPromLikeMap[labelOperator];\n              if (labelComparator) {\n                labelMatchers.push({ name: labelKey, operator: labelComparator, value: labelValue });\n              }\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  return labelMatchers;\n}\n\n/**\n * Calculates new interval \"snapped\" to the closest Nth minute, depending on cache level datasource setting\n * @param cacheLevel\n * @param range\n */\nexport function getRangeSnapInterval(\n  cacheLevel: PrometheusCacheLevel,\n  range: TimeRange\n): { start: string; end: string } {\n  // Don't round the range if we're not caching\n  if (cacheLevel === PrometheusCacheLevel.None) {\n    return {\n      start: getPrometheusTime(range.from, false).toString(),\n      end: getPrometheusTime(range.to, true).toString(),\n    };\n  }\n  // Otherwise round down to the nearest nth minute for the start time\n  const startTime = getPrometheusTime(range.from, false);\n  // const startTimeQuantizedSeconds = roundSecToLastMin(startTime, getClientCacheDurationInMinutes(cacheLevel)) * 60;\n  const startTimeQuantizedSeconds = incrRoundDn(startTime, getClientCacheDurationInMinutes(cacheLevel) * 60);\n\n  // And round up to the nearest nth minute for the end time\n  const endTime = getPrometheusTime(range.to, true);\n  const endTimeQuantizedSeconds = roundSecToNextMin(endTime, getClientCacheDurationInMinutes(cacheLevel)) * 60;\n\n  // If the interval was too short, we could have rounded both start and end to the same time, if so let's add one step to the end\n  if (startTimeQuantizedSeconds === endTimeQuantizedSeconds) {\n    const endTimePlusOneStep = endTimeQuantizedSeconds + getClientCacheDurationInMinutes(cacheLevel) * 60;\n    return { start: startTimeQuantizedSeconds.toString(), end: endTimePlusOneStep.toString() };\n  }\n\n  const start = startTimeQuantizedSeconds.toString();\n  const end = endTimeQuantizedSeconds.toString();\n\n  return { start, end };\n}\n\nexport function getClientCacheDurationInMinutes(cacheLevel: PrometheusCacheLevel) {\n  switch (cacheLevel) {\n    case PrometheusCacheLevel.Medium:\n      return 10;\n    case PrometheusCacheLevel.High:\n      return 60;\n    default:\n      return 1;\n  }\n}\n\nexport function getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n  if (typeof date === 'string') {\n    date = dateMath.parse(date, roundUp)!;\n  }\n\n  return Math.ceil(date.valueOf() / 1000);\n}\n\nexport function truncateResult<T>(array: T[], limit?: number): T[] {\n  if (limit === undefined) {\n    limit = PROMETHEUS_QUERY_BUILDER_MAX_RESULTS;\n  }\n  array.length = Math.min(array.length, limit);\n  return array;\n}\n"],"names":["p","_a"],"mappings":"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"}