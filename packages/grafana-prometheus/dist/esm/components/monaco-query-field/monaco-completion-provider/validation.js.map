{"version":3,"file":"validation.js","sources":["../../../../../src/components/monaco-query-field/monaco-completion-provider/validation.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/validation.ts\nimport { SyntaxNode } from '@lezer/common';\nimport { LRParser } from '@lezer/lr';\n\n// Although 0 isn't explicitly provided in the @grafana/lezer-logql library as the error node ID, it does appear to be the ID of error nodes within lezer.\nexport const ErrorId = 0;\n\ninterface ParserErrorBoundary {\n  startLineNumber: number;\n  startColumn: number;\n  endLineNumber: number;\n  endColumn: number;\n  error: string;\n}\n\ninterface ParseError {\n  text: string;\n  node: SyntaxNode;\n}\n\n/**\n * Conceived to work in combination with the MonacoQueryField component.\n * Given an original query, and it's interpolated version, it will return an array of ParserErrorBoundary\n * objects containing nodes which are actual errors. The interpolated version (even with placeholder variables)\n * is required because variables look like errors for Lezer.\n * @internal\n */\nexport function validateQuery(\n  query: string,\n  interpolatedQuery: string,\n  queryLines: string[],\n  parser: LRParser\n): ParserErrorBoundary[] | false {\n  if (!query) {\n    return false;\n  }\n\n  /**\n   * To provide support to variable interpolation in query validation, we run the parser in the interpolated\n   * query. If there are errors there, we trace them back to the original unparsed query, so we can more\n   * accurately highlight the error in the query, since it's likely that the variable name and variable value\n   * have different lengths. With this, we also exclude irrelevant parser errors that are produced by\n   * lezer not understanding $variables and $__variables, which usually generate 2 or 3 error SyntaxNode.\n   */\n  const interpolatedErrors: ParseError[] = parseQuery(interpolatedQuery, parser);\n  if (!interpolatedErrors.length) {\n    return false;\n  }\n\n  let parseErrors: ParseError[] = interpolatedErrors;\n  if (query !== interpolatedQuery) {\n    const queryErrors: ParseError[] = parseQuery(query, parser);\n    parseErrors = interpolatedErrors.flatMap(\n      (interpolatedError) =>\n        queryErrors.filter((queryError) => interpolatedError.text === queryError.text) || interpolatedError\n    );\n  }\n\n  return parseErrors.map((parseError) => findErrorBoundary(query, queryLines, parseError)).filter(isErrorBoundary);\n}\n\nfunction parseQuery(query: string, parser: LRParser) {\n  const parseErrors: ParseError[] = [];\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: (nodeRef): false | void => {\n      if (nodeRef.type.id === ErrorId) {\n        const node = nodeRef.node;\n        parseErrors.push({\n          node: node,\n          text: query.substring(node.from, node.to),\n        });\n      }\n    },\n  });\n  return parseErrors;\n}\n\nfunction findErrorBoundary(query: string, queryLines: string[], parseError: ParseError): ParserErrorBoundary | null {\n  if (queryLines.length === 1) {\n    const isEmptyString = parseError.node.from === parseError.node.to;\n    const errorNode = isEmptyString && parseError.node.parent ? parseError.node.parent : parseError.node;\n    const error = isEmptyString ? query.substring(errorNode.from, errorNode.to) : parseError.text;\n    return {\n      startLineNumber: 1,\n      startColumn: errorNode.from + 1,\n      endLineNumber: 1,\n      endColumn: errorNode.to + 1,\n      error,\n    };\n  }\n\n  let startPos = 0,\n    endPos = 0;\n  for (let line = 0; line < queryLines.length; line++) {\n    endPos = startPos + queryLines[line].length;\n\n    if (parseError.node.from > endPos) {\n      startPos += queryLines[line].length + 1;\n      continue;\n    }\n\n    return {\n      startLineNumber: line + 1,\n      startColumn: parseError.node.from - startPos + 1,\n      endLineNumber: line + 1,\n      endColumn: parseError.node.to - startPos + 1,\n      error: parseError.text,\n    };\n  }\n\n  return null;\n}\n\nfunction isErrorBoundary(boundary: ParserErrorBoundary | null): boundary is ParserErrorBoundary {\n  return boundary !== null;\n}\n\nexport const placeHolderScopedVars = {\n  __interval: { text: '1s', value: '1s' },\n  __rate_interval: { text: '1s', value: '1s' },\n  __auto: { text: '1s', value: '1s' },\n  __interval_ms: { text: '1000', value: 1000 },\n  __range_ms: { text: '1000', value: 1000 },\n  __range_s: { text: '1', value: 1 },\n  __range: { text: '1s', value: '1s' },\n};\n"],"names":[],"mappings":"AAKO,MAAM,OAAU,GAAA,EAAA;AAsBhB,SAAS,aACd,CAAA,KAAA,EACA,iBACA,EAAA,UAAA,EACA,MAC+B,EAAA;AAC/B,EAAA,IAAI,CAAC,KAAO,EAAA;AACV,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AASA,EAAM,MAAA,kBAAA,GAAmC,UAAW,CAAA,iBAAA,EAAmB,MAAM,CAAA,CAAA;AAC7E,EAAI,IAAA,CAAC,mBAAmB,MAAQ,EAAA;AAC9B,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAEA,EAAA,IAAI,WAA4B,GAAA,kBAAA,CAAA;AAChC,EAAA,IAAI,UAAU,iBAAmB,EAAA;AAC/B,IAAM,MAAA,WAAA,GAA4B,UAAW,CAAA,KAAA,EAAO,MAAM,CAAA,CAAA;AAC1D,IAAA,WAAA,GAAc,kBAAmB,CAAA,OAAA;AAAA,MAC/B,CAAC,iBACC,KAAA,WAAA,CAAY,MAAO,CAAA,CAAC,eAAe,iBAAkB,CAAA,IAAA,KAAS,UAAW,CAAA,IAAI,CAAK,IAAA,iBAAA;AAAA,KACtF,CAAA;AAAA,GACF;AAEA,EAAO,OAAA,WAAA,CAAY,GAAI,CAAA,CAAC,UAAe,KAAA,iBAAA,CAAkB,KAAO,EAAA,UAAA,EAAY,UAAU,CAAC,CAAE,CAAA,MAAA,CAAO,eAAe,CAAA,CAAA;AACjH,CAAA;AAEA,SAAS,UAAA,CAAW,OAAe,MAAkB,EAAA;AACnD,EAAA,MAAM,cAA4B,EAAC,CAAA;AACnC,EAAM,MAAA,IAAA,GAAO,MAAO,CAAA,KAAA,CAAM,KAAK,CAAA,CAAA;AAC/B,EAAA,IAAA,CAAK,OAAQ,CAAA;AAAA,IACX,KAAA,EAAO,CAAC,OAA0B,KAAA;AAChC,MAAI,IAAA,OAAA,CAAQ,IAAK,CAAA,EAAA,KAAO,OAAS,EAAA;AAC/B,QAAA,MAAM,OAAO,OAAQ,CAAA,IAAA,CAAA;AACrB,QAAA,WAAA,CAAY,IAAK,CAAA;AAAA,UACf,IAAA;AAAA,UACA,MAAM,KAAM,CAAA,SAAA,CAAU,IAAK,CAAA,IAAA,EAAM,KAAK,EAAE,CAAA;AAAA,SACzC,CAAA,CAAA;AAAA,OACH;AAAA,KACF;AAAA,GACD,CAAA,CAAA;AACD,EAAO,OAAA,WAAA,CAAA;AACT,CAAA;AAEA,SAAS,iBAAA,CAAkB,KAAe,EAAA,UAAA,EAAsB,UAAoD,EAAA;AAClH,EAAI,IAAA,UAAA,CAAW,WAAW,CAAG,EAAA;AAC3B,IAAA,MAAM,aAAgB,GAAA,UAAA,CAAW,IAAK,CAAA,IAAA,KAAS,WAAW,IAAK,CAAA,EAAA,CAAA;AAC/D,IAAM,MAAA,SAAA,GAAY,iBAAiB,UAAW,CAAA,IAAA,CAAK,SAAS,UAAW,CAAA,IAAA,CAAK,SAAS,UAAW,CAAA,IAAA,CAAA;AAChG,IAAM,MAAA,KAAA,GAAQ,gBAAgB,KAAM,CAAA,SAAA,CAAU,UAAU,IAAM,EAAA,SAAA,CAAU,EAAE,CAAA,GAAI,UAAW,CAAA,IAAA,CAAA;AACzF,IAAO,OAAA;AAAA,MACL,eAAiB,EAAA,CAAA;AAAA,MACjB,WAAA,EAAa,UAAU,IAAO,GAAA,CAAA;AAAA,MAC9B,aAAe,EAAA,CAAA;AAAA,MACf,SAAA,EAAW,UAAU,EAAK,GAAA,CAAA;AAAA,MAC1B,KAAA;AAAA,KACF,CAAA;AAAA,GACF;AAEA,EAAI,IAAA,QAAA,GAAW,GACb,MAAS,GAAA,CAAA,CAAA;AACX,EAAA,KAAA,IAAS,IAAO,GAAA,CAAA,EAAG,IAAO,GAAA,UAAA,CAAW,QAAQ,IAAQ,EAAA,EAAA;AACnD,IAAS,MAAA,GAAA,QAAA,GAAW,UAAW,CAAA,IAAI,CAAE,CAAA,MAAA,CAAA;AAErC,IAAI,IAAA,UAAA,CAAW,IAAK,CAAA,IAAA,GAAO,MAAQ,EAAA;AACjC,MAAY,QAAA,IAAA,UAAA,CAAW,IAAI,CAAA,CAAE,MAAS,GAAA,CAAA,CAAA;AACtC,MAAA,SAAA;AAAA,KACF;AAEA,IAAO,OAAA;AAAA,MACL,iBAAiB,IAAO,GAAA,CAAA;AAAA,MACxB,WAAa,EAAA,UAAA,CAAW,IAAK,CAAA,IAAA,GAAO,QAAW,GAAA,CAAA;AAAA,MAC/C,eAAe,IAAO,GAAA,CAAA;AAAA,MACtB,SAAW,EAAA,UAAA,CAAW,IAAK,CAAA,EAAA,GAAK,QAAW,GAAA,CAAA;AAAA,MAC3C,OAAO,UAAW,CAAA,IAAA;AAAA,KACpB,CAAA;AAAA,GACF;AAEA,EAAO,OAAA,IAAA,CAAA;AACT,CAAA;AAEA,SAAS,gBAAgB,QAAuE,EAAA;AAC9F,EAAA,OAAO,QAAa,KAAA,IAAA,CAAA;AACtB,CAAA;AAEO,MAAM,qBAAwB,GAAA;AAAA,EACnC,UAAY,EAAA,EAAE,IAAM,EAAA,IAAA,EAAM,OAAO,IAAK,EAAA;AAAA,EACtC,eAAiB,EAAA,EAAE,IAAM,EAAA,IAAA,EAAM,OAAO,IAAK,EAAA;AAAA,EAC3C,MAAQ,EAAA,EAAE,IAAM,EAAA,IAAA,EAAM,OAAO,IAAK,EAAA;AAAA,EAClC,aAAe,EAAA,EAAE,IAAM,EAAA,MAAA,EAAQ,OAAO,GAAK,EAAA;AAAA,EAC3C,UAAY,EAAA,EAAE,IAAM,EAAA,MAAA,EAAQ,OAAO,GAAK,EAAA;AAAA,EACxC,SAAW,EAAA,EAAE,IAAM,EAAA,GAAA,EAAK,OAAO,CAAE,EAAA;AAAA,EACjC,OAAS,EAAA,EAAE,IAAM,EAAA,IAAA,EAAM,OAAO,IAAK,EAAA;AACrC;;;;"}