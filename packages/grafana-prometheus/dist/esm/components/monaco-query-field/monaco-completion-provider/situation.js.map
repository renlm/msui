{"version":3,"file":"situation.js","sources":["../../../../../src/components/monaco-query-field/monaco-completion-provider/situation.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/situation.ts\nimport type { SyntaxNode, Tree } from '@lezer/common';\nimport {\n  AggregateExpr,\n  AggregateModifier,\n  BinaryExpr,\n  EqlRegex,\n  EqlSingle,\n  FunctionCallBody,\n  GroupingLabels,\n  Identifier,\n  LabelMatcher,\n  LabelMatchers,\n  LabelName,\n  MatchOp,\n  MatrixSelector,\n  Neq,\n  NeqRegex,\n  parser,\n  PromQL,\n  StringLiteral,\n  VectorSelector,\n} from '@prometheus-io/lezer-promql';\n\nimport { NeverCaseError } from './util';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\n\ntype NodeTypeId =\n  | 0 // this is used as error-id\n  | typeof AggregateExpr\n  | typeof AggregateModifier\n  | typeof FunctionCallBody\n  | typeof GroupingLabels\n  | typeof Identifier\n  | typeof LabelMatcher\n  | typeof LabelMatchers\n  | typeof LabelName\n  | typeof PromQL\n  | typeof StringLiteral\n  | typeof VectorSelector\n  | typeof MatrixSelector\n  | typeof MatchOp\n  | typeof EqlSingle\n  | typeof Neq\n  | typeof EqlRegex\n  | typeof NeqRegex;\n\ntype Path = Array<[Direction, NodeTypeId]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  switch (direction) {\n    case 'parent':\n      return node.parent;\n    case 'firstChild':\n      return node.firstChild;\n    case 'lastChild':\n      return node.lastChild;\n    case 'nextSibling':\n      return node.nextSibling;\n    default:\n      throw new NeverCaseError(direction);\n  }\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedType] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.id !== expectedType) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parsePromQLStringLiteral(text: string): string {\n  // if it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // FIXME: support https://prometheus.io/docs/prometheus/latest/querying/basics/#string-literals\n  // FIXME: maybe check other promql code, if all is supported or not\n\n  // for now we do only some very simple un-escaping\n\n  // we start with double-quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/, '\"');\n  }\n\n  // then single-quote\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/, \"'\");\n  }\n\n  // then backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error('FIXME: invalid string literal');\n}\n\ntype LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'IN_FUNCTION';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'IN_DURATION';\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      metricName?: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_GROUPING';\n      metricName: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      metricName?: string;\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    };\n\ntype Resolver = {\n  path: NodeTypeId[];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: NodeTypeId[], cursorPath: number[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_NAME: NodeTypeId = 0; // this is used as error-id\n\nconst RESOLVERS: Resolver[] = [\n  {\n    path: [LabelMatchers, VectorSelector],\n    fun: resolveLabelKeysWithEquals,\n  },\n  {\n    path: [PromQL],\n    fun: resolveTopLevel,\n  },\n  {\n    path: [FunctionCallBody],\n    fun: resolveInFunction,\n  },\n  {\n    path: [StringLiteral, LabelMatcher],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, BinaryExpr, PromQL],\n    fun: resolveTopLevel,\n  },\n  {\n    path: [ERROR_NODE_NAME, LabelMatcher],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, MatrixSelector],\n    fun: resolveDurations,\n  },\n  {\n    path: [GroupingLabels],\n    fun: resolveLabelsForGrouping,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<number, LabelOperator>([\n  [EqlSingle, '='],\n  [EqlRegex, '=~'],\n  [Neq, '!='],\n  [NeqRegex, '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  const opChild = opNode.firstChild;\n  if (opChild === null) {\n    return null;\n  }\n\n  return LABEL_OP_MAP.get(opChild.type.id) ?? null;\n}\n\nfunction getLabel(labelMatcherNode: SyntaxNode, text: string): Label | null {\n  if (labelMatcherNode.type.id !== LabelMatcher) {\n    return null;\n  }\n\n  const nameNode = walk(labelMatcherNode, [['firstChild', LabelName]]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = walk(nameNode, [['nextSibling', MatchOp]]);\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(labelMatcherNode, [['lastChild', StringLiteral]]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parsePromQLStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\n\nfunction getLabels(labelMatchersNode: SyntaxNode, text: string): Label[] {\n  if (labelMatchersNode.type.id !== LabelMatchers) {\n    return [];\n  }\n\n  const labelNodes = labelMatchersNode.getChildren(LabelMatcher);\n  return labelNodes.map((ln) => getLabel(ln, text)).filter(notEmpty);\n}\n\nfunction getNodeChildren(node: SyntaxNode): SyntaxNode[] {\n  let child: SyntaxNode | null = node.firstChild;\n  const children: SyntaxNode[] = [];\n  while (child !== null) {\n    children.push(child);\n    child = child.nextSibling;\n  }\n  return children;\n}\n\nfunction getNodeInSubtree(node: SyntaxNode, typeId: NodeTypeId): SyntaxNode | null {\n  // first we try the current node\n  if (node.type.id === typeId) {\n    return node;\n  }\n\n  // then we try the children\n  const children = getNodeChildren(node);\n  for (const child of children) {\n    const n = getNodeInSubtree(child, typeId);\n    if (n !== null) {\n      return n;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [\n    ['parent', AggregateModifier],\n    ['parent', AggregateExpr],\n  ]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild(FunctionCallBody);\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const metricIdNode = getNodeInSubtree(bodyNode, Identifier);\n  if (metricIdNode === null) {\n    return null;\n  }\n\n  const metricName = getNodeText(metricIdNode, text);\n  return {\n    type: 'IN_GROUPING',\n    metricName,\n    otherLabels: [],\n  };\n}\n\nfunction resolveLabelMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here in two situation. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', LabelMatcher]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', LabelName]]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  const labelMatchersNode = walk(parent, [['parent', LabelMatchers]]);\n  if (labelMatchersNode === null) {\n    return null;\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(labelMatchersNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  const metricNameNode = walk(labelMatchersNode, [\n    ['parent', VectorSelector],\n    ['firstChild', Identifier],\n  ]);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name\n    return {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n      labelName,\n      betweenQuotes: inStringNode,\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    metricName,\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'AT_ROOT',\n  };\n}\n\nfunction resolveInFunction(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_FUNCTION',\n  };\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_DURATION',\n  };\n}\n\nfunction resolveLabelKeysWithEquals(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // next false positive:\n  // `something{a=\"1\"^}`\n  const child = walk(node, [['firstChild', LabelMatcher]]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const metricNameNode = walk(node, [\n    ['parent', VectorSelector],\n    ['firstChild', Identifier],\n  ]);\n\n  const otherLabels = getLabels(node, text);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name.\n    return {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    metricName,\n    otherLabels,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, pos: number): SyntaxNode | null {\n  const cur = tree.cursorAt(pos);\n  while (true) {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n\n    if (!cur.next()) {\n      break;\n    }\n  }\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special-case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  /**\n   PromQL\n   Expr\n   VectorSelector\n   LabelMatchers\n   */\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error-nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error-node at the cursor-position\n  const maybeErrorNode = getErrorNode(tree, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor() : tree.cursorAt(pos);\n  const currentNode = cur.node;\n\n  const ids = [cur.type.id];\n  while (cur.parent()) {\n    ids.push(cur.type.id);\n  }\n\n  for (let resolver of RESOLVERS) {\n    // i do not use a foreach because i want to stop as soon\n    // as i find something\n    if (isPathMatch(resolver.path, ids)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}\n\nfunction notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  return value !== null && value !== undefined;\n}\n"],"names":[],"mappings":"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"}