{"version":3,"file":"LabelParamEditor.js","sources":["../../../../src/querybuilder/components/LabelParamEditor.tsx"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx\nimport React, { useState } from 'react';\n\nimport { DataSourceApi, SelectableValue, toOption } from '@grafana/data';\nimport { Select } from '@grafana/ui';\n\nimport { promQueryModeller } from '../PromQueryModeller';\nimport { getOperationParamId } from '../operationUtils';\nimport { QueryBuilderLabelFilter, QueryBuilderOperationParamEditorProps } from '../shared/types';\nimport { PromVisualQuery } from '../types';\n\nexport function LabelParamEditor({\n  onChange,\n  index,\n  operationId,\n  value,\n  query,\n  datasource,\n}: QueryBuilderOperationParamEditorProps) {\n  const [state, setState] = useState<{\n    options?: SelectableValue[];\n    isLoading?: boolean;\n  }>({});\n\n  return (\n    <Select\n      inputId={getOperationParamId(operationId, index)}\n      autoFocus={value === '' ? true : undefined}\n      openMenuOnFocus\n      onOpenMenu={async () => {\n        setState({ isLoading: true });\n        const options = await loadGroupByLabels(query, datasource);\n        setState({ options, isLoading: undefined });\n      }}\n      isLoading={state.isLoading}\n      allowCustomValue\n      noOptionsMessage=\"No labels found\"\n      loadingMessage=\"Loading labels\"\n      options={state.options}\n      value={toOption(value as string)}\n      onChange={(value) => onChange(index, value.value!)}\n    />\n  );\n}\n\nasync function loadGroupByLabels(query: PromVisualQuery, datasource: DataSourceApi): Promise<SelectableValue[]> {\n  let labels: QueryBuilderLabelFilter[] = query.labels;\n\n  // This function is used by both Prometheus and Loki and this the only difference.\n  if (datasource.type === 'prometheus') {\n    labels = [{ label: '__name__', op: '=', value: query.metric }, ...query.labels];\n  }\n\n  const expr = promQueryModeller.renderLabels(labels);\n  const result = await datasource.languageProvider.fetchLabelsWithMatch(expr);\n\n  return Object.keys(result).map((x) => ({\n    label: x,\n    value: x,\n  }));\n}\n"],"names":["value"],"mappings":";;;;;;AAWO,SAAS,gBAAiB,CAAA;AAAA,EAC/B,QAAA;AAAA,EACA,KAAA;AAAA,EACA,WAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AAAA,EACA,UAAA;AACF,CAA0C,EAAA;AACxC,EAAA,MAAM,CAAC,KAAO,EAAA,QAAQ,CAAI,GAAA,QAAA,CAGvB,EAAE,CAAA,CAAA;AAEL,EACE,uBAAA,KAAA,CAAA,aAAA;AAAA,IAAC,MAAA;AAAA,IAAA;AAAA,MACC,OAAA,EAAS,mBAAoB,CAAA,WAAA,EAAa,KAAK,CAAA;AAAA,MAC/C,SAAA,EAAW,KAAU,KAAA,EAAA,GAAK,IAAO,GAAA,KAAA,CAAA;AAAA,MACjC,eAAe,EAAA,IAAA;AAAA,MACf,YAAY,YAAY;AACtB,QAAS,QAAA,CAAA,EAAE,SAAW,EAAA,IAAA,EAAM,CAAA,CAAA;AAC5B,QAAA,MAAM,OAAU,GAAA,MAAM,iBAAkB,CAAA,KAAA,EAAO,UAAU,CAAA,CAAA;AACzD,QAAA,QAAA,CAAS,EAAE,OAAA,EAAS,SAAW,EAAA,KAAA,CAAA,EAAW,CAAA,CAAA;AAAA,OAC5C;AAAA,MACA,WAAW,KAAM,CAAA,SAAA;AAAA,MACjB,gBAAgB,EAAA,IAAA;AAAA,MAChB,gBAAiB,EAAA,iBAAA;AAAA,MACjB,cAAe,EAAA,gBAAA;AAAA,MACf,SAAS,KAAM,CAAA,OAAA;AAAA,MACf,KAAA,EAAO,SAAS,KAAe,CAAA;AAAA,MAC/B,UAAU,CAACA,MAAAA,KAAU,QAAS,CAAA,KAAA,EAAOA,OAAM,KAAM,CAAA;AAAA,KAAA;AAAA,GACnD,CAAA;AAEJ,CAAA;AAEA,eAAe,iBAAA,CAAkB,OAAwB,UAAuD,EAAA;AAC9G,EAAA,IAAI,SAAoC,KAAM,CAAA,MAAA,CAAA;AAG9C,EAAI,IAAA,UAAA,CAAW,SAAS,YAAc,EAAA;AACpC,IAAA,MAAA,GAAS,CAAC,EAAE,KAAO,EAAA,UAAA,EAAY,EAAI,EAAA,GAAA,EAAK,KAAO,EAAA,KAAA,CAAM,MAAO,EAAA,EAAG,GAAG,KAAA,CAAM,MAAM,CAAA,CAAA;AAAA,GAChF;AAEA,EAAM,MAAA,IAAA,GAAO,iBAAkB,CAAA,YAAA,CAAa,MAAM,CAAA,CAAA;AAClD,EAAA,MAAM,MAAS,GAAA,MAAM,UAAW,CAAA,gBAAA,CAAiB,qBAAqB,IAAI,CAAA,CAAA;AAE1E,EAAA,OAAO,OAAO,IAAK,CAAA,MAAM,CAAE,CAAA,GAAA,CAAI,CAAC,CAAO,MAAA;AAAA,IACrC,KAAO,EAAA,CAAA;AAAA,IACP,KAAO,EAAA,CAAA;AAAA,GACP,CAAA,CAAA,CAAA;AACJ;;;;"}