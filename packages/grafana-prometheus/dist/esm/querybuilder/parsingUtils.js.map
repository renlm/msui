{"version":3,"file":"parsingUtils.js","sources":["../../../src/querybuilder/parsingUtils.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/querybuilder/parsingUtils.ts\nimport { SyntaxNode, TreeCursor } from '@lezer/common';\n\nimport { QueryBuilderOperation, QueryBuilderOperationParamValue } from './shared/types';\n\n// Although 0 isn't explicitly provided in the lezer-promql library as the error node ID, it does appear to be the ID of error nodes within lezer.\nexport const ErrorId = 0;\n\nexport function getLeftMostChild(cur: SyntaxNode): SyntaxNode {\n  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;\n}\n\nexport function makeError(expr: string, node: SyntaxNode) {\n  return {\n    text: getString(expr, node),\n    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact\n    //  placement of the error for the user. We need some translation table to positions before the variable\n    //  replace.\n    from: node.from,\n    to: node.to,\n    parentType: node.parent?.name,\n  };\n}\n\n// Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\nconst variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::([^\\}]+))?}/g;\n\n/**\n * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at\n * the same time we can get the variable and its format back from it.\n * @param expr\n */\nexport function replaceVariables(expr: string) {\n  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {\n    const fmt = fmt2 || fmt3;\n    let variable = var1;\n    let varType = '0';\n\n    if (var2) {\n      variable = var2;\n      varType = '1';\n    }\n\n    if (var3) {\n      variable = var3;\n      varType = '2';\n    }\n\n    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');\n  });\n}\n\nconst varTypeFunc = [\n  (v: string, f?: string) => `\\$${v}`,\n  (v: string, f?: string) => `[[${v}${f ? `:${f}` : ''}]]`,\n  (v: string, f?: string) => `\\$\\{${v}${f ? `:${f}` : ''}\\}`,\n];\n\n/**\n * Get back the text with variables in their original format.\n * @param expr\n */\nexport function returnVariables(expr: string) {\n  return expr.replace(/__V_(\\d)__(.+?)__V__(?:__F__(\\w+)__F__)?/g, (match, type, v, f) => {\n    return varTypeFunc[parseInt(type, 10)](v, f);\n  });\n}\n\n/**\n * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node\n * and then based on that get it from the expression.\n * @param expr\n * @param node\n */\nexport function getString(expr: string, node: SyntaxNode | TreeCursor | null | undefined) {\n  if (!node) {\n    return '';\n  }\n  return returnVariables(expr.substring(node.from, node.to));\n}\n\n/**\n * Create simple scalar binary op object.\n * @param opDef - definition of the op to be created\n * @param expr\n * @param numberNode - the node for the scalar\n * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.\n */\nexport function makeBinOp(\n  opDef: { id: string; comparison?: boolean },\n  expr: string,\n  numberNode: SyntaxNode,\n  hasBool: boolean\n): QueryBuilderOperation {\n  const params: QueryBuilderOperationParamValue[] = [parseFloat(getString(expr, numberNode))];\n  if (opDef.comparison) {\n    params.push(hasBool);\n  }\n  return {\n    id: opDef.id,\n    params,\n  };\n}\n\n/**\n * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be\n * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would\n * not be safe is it would also find arguments of nested functions.\n * @param expr\n * @param cur\n * @param type\n */\nexport function getAllByType(expr: string, cur: SyntaxNode, type: number): string[] {\n  if (cur.type.id === type) {\n    return [getString(expr, cur)];\n  }\n  const values: string[] = [];\n  let pos = 0;\n  let child = cur.childAfter(pos);\n  while (child) {\n    values.push(...getAllByType(expr, child, type));\n    pos = child.to;\n    child = cur.childAfter(pos);\n  }\n  return values;\n}\n\n/**\n * There aren't any spaces in the metric names, so let's introduce a wildcard into the regex for each space to better facilitate a fuzzy search\n */\nexport const regexifyLabelValuesQueryString = (query: string) => {\n  const queryArray = query.split(' ');\n  return queryArray.map((query) => `${query}.*`).join('');\n};\n"],"names":["query"],"mappings":"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"}