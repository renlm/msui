{"version":3,"file":"parsing.js","sources":["../../../src/querybuilder/parsing.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/querybuilder/parsing.ts\nimport { SyntaxNode } from '@lezer/common';\nimport {\n  AggregateExpr,\n  AggregateModifier,\n  AggregateOp,\n  BinaryExpr,\n  BoolModifier,\n  FunctionCall,\n  FunctionCallBody,\n  FunctionIdentifier,\n  GroupingLabels,\n  Identifier,\n  LabelMatcher,\n  LabelName,\n  MatchingModifierClause,\n  MatchOp,\n  NumberLiteral,\n  On,\n  ParenExpr,\n  parser,\n  StringLiteral,\n  VectorSelector,\n  Without,\n} from '@prometheus-io/lezer-promql';\n\nimport { binaryScalarOperatorToOperatorName } from './binaryScalarOperations';\nimport {\n  ErrorId,\n  getAllByType,\n  getLeftMostChild,\n  getString,\n  makeBinOp,\n  makeError,\n  replaceVariables,\n} from './parsingUtils';\nimport { QueryBuilderLabelFilter, QueryBuilderOperation } from './shared/types';\nimport { PromVisualQuery, PromVisualQueryBinary } from './types';\n\n/**\n * Parses a PromQL query into a visual query model.\n *\n * It traverses the tree and uses sort of state machine to update the query model. The query model is modified\n * during the traversal and sent to each handler as context.\n *\n * @param expr\n */\nexport function buildVisualQueryFromString(expr: string): Context {\n  const replacedExpr = replaceVariables(expr);\n  const tree = parser.parse(replacedExpr);\n  const node = tree.topNode;\n\n  // This will be modified in the handlers.\n  const visQuery: PromVisualQuery = {\n    metric: '',\n    labels: [],\n    operations: [],\n  };\n  const context: Context = {\n    query: visQuery,\n    errors: [],\n  };\n\n  try {\n    handleExpression(replacedExpr, node, context);\n  } catch (err) {\n    // Not ideal to log it here, but otherwise we would lose the stack trace.\n    console.error(err);\n    if (err instanceof Error) {\n      context.errors.push({\n        text: err.message,\n      });\n    }\n  }\n\n  // If we have empty query, we want to reset errors\n  if (isEmptyQuery(context.query)) {\n    context.errors = [];\n  }\n\n  // We don't want parsing errors related to Grafana global variables\n  if (isValidPromQLMinusGrafanaGlobalVariables(expr)) {\n    context.errors = [];\n  }\n\n  return context;\n}\n\ninterface ParsingError {\n  text: string;\n  from?: number;\n  to?: number;\n  parentType?: string;\n}\n\ninterface Context {\n  query: PromVisualQuery;\n  errors: ParsingError[];\n}\n\n// TODO find a better approach for grafana global variables\nfunction isValidPromQLMinusGrafanaGlobalVariables(expr: string) {\n  const context: Context = {\n    query: {\n      metric: '',\n      labels: [],\n      operations: [],\n    },\n    errors: [],\n  };\n\n  expr = expr.replace(/\\$__interval/g, '1s');\n  expr = expr.replace(/\\$__interval_ms/g, '1000');\n  expr = expr.replace(/\\$__rate_interval/g, '1s');\n  expr = expr.replace(/\\$__range_ms/g, '1000');\n  expr = expr.replace(/\\$__range_s/g, '1');\n  expr = expr.replace(/\\$__range/g, '1s');\n\n  const tree = parser.parse(expr);\n  const node = tree.topNode;\n\n  try {\n    handleExpression(expr, node, context);\n  } catch (err) {\n    return false;\n  }\n\n  return context.errors.length === 0;\n}\n\n/**\n * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node\n * handled here does not necessarily need to be of type == Expr.\n * @param expr\n * @param node\n * @param context\n */\nexport function handleExpression(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n\n  switch (node.type.id) {\n    case Identifier: {\n      // Expectation is that there is only one of those per query.\n      visQuery.metric = getString(expr, node);\n      break;\n    }\n\n    case LabelMatcher: {\n      // Same as MetricIdentifier should be just one per query.\n      visQuery.labels.push(getLabel(expr, node));\n      const err = node.getChild(ErrorId);\n      if (err) {\n        context.errors.push(makeError(expr, err));\n      }\n      break;\n    }\n\n    case FunctionCall: {\n      handleFunction(expr, node, context);\n      break;\n    }\n\n    case AggregateExpr: {\n      handleAggregation(expr, node, context);\n      break;\n    }\n\n    case BinaryExpr: {\n      handleBinary(expr, node, context);\n      break;\n    }\n\n    case ErrorId: {\n      if (isIntervalVariableError(node)) {\n        break;\n      }\n      context.errors.push(makeError(expr, node));\n      break;\n    }\n\n    default: {\n      if (node.type.id === ParenExpr) {\n        // We don't support parenthesis in the query to group expressions.\n        // We just report error but go on with the parsing.\n        context.errors.push(makeError(expr, node));\n      }\n      // Any other nodes we just ignore and go to its children. This should be fine as there are lots of wrapper\n      // nodes that can be skipped.\n      // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to\n      //  detect those and report back.\n      let child = node.firstChild;\n      while (child) {\n        handleExpression(expr, child, context);\n        child = child.nextSibling;\n      }\n    }\n  }\n}\n\n// TODO check if we still need this\nfunction isIntervalVariableError(node: SyntaxNode) {\n  return node.prevSibling?.firstChild?.type.id === VectorSelector;\n}\n\nfunction getLabel(expr: string, node: SyntaxNode): QueryBuilderLabelFilter {\n  const label = getString(expr, node.getChild(LabelName));\n  const op = getString(expr, node.getChild(MatchOp));\n  const value = getString(expr, node.getChild(StringLiteral)).replace(/\"/g, '');\n  return {\n    label,\n    op,\n    value,\n  };\n}\n\nconst rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];\n\n/**\n * Handle function call which is usually and identifier and its body > arguments.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleFunction(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const nameNode = node.getChild(FunctionIdentifier);\n  const funcName = getString(expr, nameNode);\n\n  const body = node.getChild(FunctionCallBody);\n  const params = [];\n  let interval = '';\n\n  // This is a bit of a shortcut to get the interval argument. Reasons are\n  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in\n  //   the query model.\n  // - it is easier to handle template variables this way as template variable is an error for the parser\n  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {\n    let match = getString(expr, node).match(/\\[(.+)\\]/);\n    if (match?.[1]) {\n      interval = match[1];\n      params.push(match[1]);\n    }\n  }\n\n  const op = { id: funcName, params };\n  // We unshift operations to keep the more natural order that we want to have in the visual query editor.\n  visQuery.operations.unshift(op);\n\n  if (body) {\n    if (getString(expr, body) === '([' + interval + '])') {\n      // This is a special case where we have a function with a single argument and it is the interval.\n      // This happens when you start adding operations in query builder and did not set a metric yet.\n      return;\n    }\n    updateFunctionArgs(expr, body, context, op);\n  }\n}\n\n/**\n * Handle aggregation as they are distinct type from other functions.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleAggregation(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const nameNode = node.getChild(AggregateOp);\n  let funcName = getString(expr, nameNode);\n\n  const modifier = node.getChild(AggregateModifier);\n  const labels = [];\n\n  if (modifier) {\n    const byModifier = modifier.getChild(`By`);\n    if (byModifier && funcName) {\n      funcName = `__${funcName}_by`;\n    }\n\n    const withoutModifier = modifier.getChild(Without);\n    if (withoutModifier) {\n      funcName = `__${funcName}_without`;\n    }\n\n    labels.push(...getAllByType(expr, modifier, LabelName));\n  }\n\n  const body = node.getChild(FunctionCallBody);\n\n  const op: QueryBuilderOperation = { id: funcName, params: [] };\n  visQuery.operations.unshift(op);\n  updateFunctionArgs(expr, body, context, op);\n  // We add labels after params in the visual query editor.\n  op.params.push(...labels);\n}\n\n/**\n * Handle (probably) all types of arguments that function or aggregation can have.\n *\n * We cannot just get all the children and iterate them as arguments we have to again recursively traverse through\n *  them.\n *\n * @param expr\n * @param node\n * @param context\n * @param op - We need the operation to add the params to as an additional context.\n */\nfunction updateFunctionArgs(expr: string, node: SyntaxNode | null, context: Context, op: QueryBuilderOperation) {\n  if (!node) {\n    return;\n  }\n  switch (node.type.id) {\n    case FunctionCallBody: {\n      let child = node.firstChild;\n\n      while (child) {\n        let binaryExpressionWithinFunctionArgs: SyntaxNode | null;\n        if (child.type.id === BinaryExpr) {\n          binaryExpressionWithinFunctionArgs = child;\n        } else {\n          binaryExpressionWithinFunctionArgs = child.getChild(BinaryExpr);\n        }\n\n        if (binaryExpressionWithinFunctionArgs) {\n          context.errors.push({\n            text: 'Query parsing is ambiguous.',\n            from: binaryExpressionWithinFunctionArgs.from,\n            to: binaryExpressionWithinFunctionArgs.to,\n          });\n        }\n\n        updateFunctionArgs(expr, child, context, op);\n        child = child.nextSibling;\n      }\n      break;\n    }\n\n    case NumberLiteral: {\n      op.params.push(parseFloat(getString(expr, node)));\n      break;\n    }\n\n    case StringLiteral: {\n      op.params.push(getString(expr, node).replace(/\"/g, ''));\n      break;\n    }\n\n    default: {\n      // Means we get to something that does not seem like simple function arg and is probably nested query so jump\n      // back to main context\n      handleExpression(expr, node, context);\n    }\n  }\n}\n\n/**\n * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is\n * just operation with scalar or it creates a binaryQuery when it's 2 queries.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleBinary(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const left = node.firstChild!;\n  const op = getString(expr, left.nextSibling);\n  const binModifier = getBinaryModifier(expr, node.getChild(BoolModifier) ?? node.getChild(MatchingModifierClause));\n\n  const right = node.lastChild!;\n\n  const opDef = binaryScalarOperatorToOperatorName[op];\n\n  const leftNumber = left.type.id === NumberLiteral;\n  const rightNumber = right.type.id === NumberLiteral;\n\n  const rightBinary = right.type.id === BinaryExpr;\n\n  if (leftNumber) {\n    // TODO: this should be already handled in case parent is binary expression as it has to be added to parent\n    //  if query starts with a number that isn't handled now.\n  } else {\n    // If this is binary we don't really know if there is a query or just chained scalars. So\n    // we have to traverse a bit deeper to know\n    handleExpression(expr, left, context);\n  }\n\n  if (rightNumber) {\n    visQuery.operations.push(makeBinOp(opDef, expr, right, !!binModifier?.isBool));\n  } else if (rightBinary) {\n    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which\n    // is a factor for a current binary operation. So we have to add it as an operation now.\n    const leftMostChild = getLeftMostChild(right);\n    if (leftMostChild?.type.id === NumberLiteral) {\n      visQuery.operations.push(makeBinOp(opDef, expr, leftMostChild, !!binModifier?.isBool));\n    }\n\n    // If we added the first number literal as operation here we still can continue and handle the rest as the first\n    // number will be just skipped.\n    handleExpression(expr, right, context);\n  } else {\n    visQuery.binaryQueries = visQuery.binaryQueries || [];\n    const binQuery: PromVisualQueryBinary = {\n      operator: op,\n      query: {\n        metric: '',\n        labels: [],\n        operations: [],\n      },\n    };\n    if (binModifier?.isMatcher) {\n      binQuery.vectorMatchesType = binModifier.matchType;\n      binQuery.vectorMatches = binModifier.matches;\n    }\n    visQuery.binaryQueries.push(binQuery);\n    handleExpression(expr, right, {\n      query: binQuery.query,\n      errors: context.errors,\n    });\n  }\n}\n\n// TODO revisit this function.\nfunction getBinaryModifier(\n  expr: string,\n  node: SyntaxNode | null\n):\n  | { isBool: true; isMatcher: false }\n  | { isBool: false; isMatcher: true; matches: string; matchType: 'ignoring' | 'on' }\n  | undefined {\n  if (!node) {\n    return undefined;\n  }\n  if (node.getChild('Bool')) {\n    return { isBool: true, isMatcher: false };\n  } else {\n    let labels = '';\n    const groupingLabels = node.getChild(GroupingLabels);\n    if (groupingLabels) {\n      labels = getAllByType(expr, groupingLabels, LabelName).join(', ');\n    }\n\n    return {\n      isMatcher: true,\n      isBool: false,\n      matches: labels,\n      matchType: node.getChild(On) ? 'on' : 'ignoring',\n    };\n  }\n}\n\nfunction isEmptyQuery(query: PromVisualQuery) {\n  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {\n    return true;\n  }\n  return false;\n}\n"],"names":[],"mappings":"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"}