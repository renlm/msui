{"version":3,"file":"amendTimeSeries.js","sources":["../../../../../../../src/gcopypaste/app/features/live/data/amendTimeSeries.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/features/live/data/amendTimeSeries.ts\nimport { closestIdx } from '@grafana/data';\n\nexport type Table = [times: number[], ...values: any[][]];\n\n// prevTable and nextTable are assumed sorted ASC on reference [0] arrays\n// nextTable is assumed to be contiguous, only edges are checked for overlap\n// ...so prev: [1,2,5] + next: [3,4,6] -> [1,2,3,4,6]\nexport function amendTable(prevTable: Table, nextTable: Table): Table {\n    let [prevTimes] = prevTable;\n    let [nextTimes] = nextTable;\n\n    let pLen = prevTimes.length;\n    let pStart = prevTimes[0];\n    let pEnd = prevTimes[pLen - 1];\n\n    let nLen = nextTimes.length;\n    let nStart = nextTimes[0];\n    let nEnd = nextTimes[nLen - 1];\n\n    let outTable: Table;\n\n    if (pLen) {\n        if (nLen) {\n            // append, no overlap\n            if (nStart > pEnd) {\n                outTable = prevTable.map((_, i) => prevTable[i].concat(nextTable[i])) as Table;\n            }\n            // prepend, no overlap\n            else if (nEnd < pStart) {\n                outTable = nextTable.map((_, i) => nextTable[i].concat(prevTable[i])) as Table;\n            }\n            // full replace\n            else if (nStart <= pStart && nEnd >= pEnd) {\n                outTable = nextTable;\n            }\n            // partial replace\n            else if (nStart > pStart && nEnd < pEnd) {\n            }\n            // append, with overlap\n            else if (nStart >= pStart) {\n                let idx = closestIdx(nStart, prevTimes);\n                idx = prevTimes[idx] < nStart ? idx - 1 : idx;\n                outTable = prevTable.map((_, i) => prevTable[i].slice(0, idx).concat(nextTable[i])) as Table;\n            }\n            // prepend, with overlap\n            else if (nEnd >= pStart) {\n                let idx = closestIdx(nEnd, prevTimes);\n                idx = prevTimes[idx] < nEnd ? idx : idx + 1;\n                outTable = nextTable.map((_, i) => nextTable[i].concat(prevTable[i].slice(idx))) as Table;\n            }\n        } else {\n            outTable = prevTable;\n        }\n    } else {\n        if (nLen) {\n            outTable = nextTable;\n        } else {\n            outTable = [[]];\n        }\n    }\n\n    return outTable!;\n}\n\nexport function trimTable(table: Table, fromTime: number, toTime: number): Table {\n    let [times, ...vals] = table;\n    let fromIdx: number | undefined;\n    let toIdx: number | undefined;\n\n    // trim to bounds\n    if (times[0] < fromTime) {\n        fromIdx = closestIdx(fromTime, times);\n\n        if (times[fromIdx] < fromTime) {\n            fromIdx++;\n        }\n    }\n\n    if (times[times.length - 1] > toTime) {\n        toIdx = closestIdx(toTime, times);\n\n        if (times[toIdx] > toTime) {\n            toIdx--;\n        }\n    }\n\n    if (fromIdx != null || toIdx != null) {\n        times = times.slice(fromIdx ?? 0, toIdx);\n        vals = vals.map(vals2 => vals2.slice(fromIdx ?? 0, toIdx));\n    }\n\n    return [times, ...vals];\n}\n"],"names":[],"mappings":"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"}