{"version":3,"file":"QueryCache.js","sources":["../../../src/querycache/QueryCache.ts"],"sourcesContent":["// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/querycache/QueryCache.ts\nimport {\n  DataFrame,\n  DataQueryRequest,\n  dateTime,\n  durationToMilliseconds,\n  Field,\n  incrRoundDn,\n  isValidDuration,\n  parseDuration,\n} from '@grafana/data';\nimport { faro } from '@grafana/faro-web-sdk';\nimport { config, reportInteraction } from '@grafana/runtime';\n\nimport { amendTable, Table, trimTable } from '../gcopypaste/app/features/live/data/amendTimeSeries';\nimport { PromQuery } from '../types';\n\n// dashboardUID + panelId + refId\n// (must be stable across query changes, time range changes / interval changes / panel resizes / template variable changes)\ntype TargetIdent = string;\n\ntype RequestID = string;\n\n// query + template variables + interval + raw time range\n// used for full target cache busting -> full range re-query\ntype TargetSig = string;\n\ntype TimestampMs = number;\n\ntype SupportedQueryTypes = PromQuery;\n\n// string matching requirements defined in durationutil.ts\nexport const defaultPrometheusQueryOverlapWindow = '10m';\n\ninterface TargetCache {\n  sig: TargetSig;\n  prevTo: TimestampMs;\n  frames: DataFrame[];\n}\n\nexport interface CacheRequestInfo<T extends SupportedQueryTypes> {\n  requests: Array<DataQueryRequest<T>>;\n  targSigs: Map<TargetIdent, TargetSig>;\n  shouldCache: boolean;\n}\n\nexport interface DatasourceProfileData {\n  interval?: string;\n  expr: string;\n  datasource: string;\n}\n\ninterface ProfileData extends DatasourceProfileData {\n  identity: string;\n  bytes: number | null;\n  dashboardUID: string;\n  panelId?: number;\n  from: string;\n  queryRangeSeconds: number;\n  refreshIntervalMs: number;\n}\n\n/**\n * Get field identity\n * This is the string used to uniquely identify a field within a \"target\"\n * @param field\n */\nexport const getFieldIdent = (field: Field) => `${field.type}|${field.name}|${JSON.stringify(field.labels ?? '')}`;\n\n/**\n * NOMENCLATURE\n * Target: The request target (DataQueryRequest), i.e. a specific query reference within a panel\n * Ident: Identity: the string that is not expected to change\n * Sig: Signature: the string that is expected to change, upon which we wipe the cache fields\n */\nexport class QueryCache<T extends SupportedQueryTypes> {\n  private overlapWindowMs: number;\n  private getTargetSignature: (request: DataQueryRequest<T>, target: T) => string;\n  private getProfileData?: (request: DataQueryRequest<T>, target: T) => DatasourceProfileData;\n\n  private perfObeserver?: PerformanceObserver;\n  private shouldProfile: boolean;\n\n  // send profile events every 10 minutes\n  sendEventsInterval = 60000 * 10;\n\n  pendingRequestIdsToTargSigs = new Map<RequestID, ProfileData>();\n\n  pendingAccumulatedEvents = new Map<\n    string,\n    {\n      requestCount: number;\n      savedBytesTotal: number;\n      initialRequestSize: number;\n      lastRequestSize: number;\n      panelId: string;\n      dashId: string;\n      expr: string;\n      refreshIntervalMs: number;\n      sent: boolean;\n      datasource: string;\n      from: string;\n      queryRangeSeconds: number;\n    }\n  >();\n\n  cache = new Map<TargetIdent, TargetCache>();\n\n  constructor(options: {\n    getTargetSignature: (request: DataQueryRequest<T>, target: T) => string;\n    overlapString: string;\n    profileFunction?: (request: DataQueryRequest<T>, target: T) => DatasourceProfileData;\n  }) {\n    const unverifiedOverlap = options.overlapString;\n    if (isValidDuration(unverifiedOverlap)) {\n      const duration = parseDuration(unverifiedOverlap);\n      this.overlapWindowMs = durationToMilliseconds(duration);\n    } else {\n      const duration = parseDuration(defaultPrometheusQueryOverlapWindow);\n      this.overlapWindowMs = durationToMilliseconds(duration);\n    }\n\n    if (\n      (config.grafanaJavascriptAgent.enabled || config.featureToggles?.prometheusIncrementalQueryInstrumentation) &&\n      options.profileFunction !== undefined\n    ) {\n      this.profile();\n      this.shouldProfile = true;\n    } else {\n      this.shouldProfile = false;\n    }\n    this.getProfileData = options.profileFunction;\n    this.getTargetSignature = options.getTargetSignature;\n  }\n\n  private profile() {\n    // Check if PerformanceObserver is supported, and if we have Faro enabled for internal profiling\n    if (typeof PerformanceObserver === 'function') {\n      this.perfObeserver = new PerformanceObserver((list: PerformanceObserverEntryList) => {\n        list.getEntries().forEach((entry) => {\n          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n          const entryTypeCast: PerformanceResourceTiming = entry as PerformanceResourceTiming;\n\n          // Safari support for this is coming in 16.4:\n          // https://caniuse.com/mdn-api_performanceresourcetiming_transfersize\n          // Gating that this exists to prevent runtime errors\n          const isSupported = typeof entryTypeCast?.transferSize === 'number';\n\n          if (entryTypeCast?.initiatorType === 'fetch' && isSupported) {\n            let fetchUrl = entryTypeCast.name;\n\n            if (fetchUrl.includes('/api/ds/query')) {\n              let match = fetchUrl.match(/requestId=([a-z\\d]+)/i);\n\n              if (match) {\n                let requestId = match[1];\n\n                const requestTransferSize = Math.round(entryTypeCast.transferSize);\n                const currentRequest = this.pendingRequestIdsToTargSigs.get(requestId);\n\n                if (currentRequest) {\n                  const entries = this.pendingRequestIdsToTargSigs.entries();\n\n                  for (let [, value] of entries) {\n                    if (value.identity === currentRequest.identity && value.bytes !== null) {\n                      const previous = this.pendingAccumulatedEvents.get(value.identity);\n\n                      const savedBytes = value.bytes - requestTransferSize;\n\n                      this.pendingAccumulatedEvents.set(value.identity, {\n                        datasource: value.datasource ?? 'N/A',\n                        requestCount: (previous?.requestCount ?? 0) + 1,\n                        savedBytesTotal: (previous?.savedBytesTotal ?? 0) + savedBytes,\n                        initialRequestSize: value.bytes,\n                        lastRequestSize: requestTransferSize,\n                        panelId: currentRequest.panelId?.toString() ?? '',\n                        dashId: currentRequest.dashboardUID ?? '',\n                        expr: currentRequest.expr ?? '',\n                        refreshIntervalMs: currentRequest.refreshIntervalMs ?? 0,\n                        sent: false,\n                        from: currentRequest.from ?? '',\n                        queryRangeSeconds: currentRequest.queryRangeSeconds ?? 0,\n                      });\n\n                      // We don't need to save each subsequent request, only the first one\n                      this.pendingRequestIdsToTargSigs.delete(requestId);\n\n                      return;\n                    }\n                  }\n\n                  // If we didn't return above, this should be the first request, let's save the observed size\n                  this.pendingRequestIdsToTargSigs.set(requestId, { ...currentRequest, bytes: requestTransferSize });\n                }\n              }\n            }\n          }\n        });\n      });\n\n      this.perfObeserver.observe({ type: 'resource', buffered: false });\n\n      setInterval(this.sendPendingTrackingEvents, this.sendEventsInterval);\n\n      // Send any pending profile information when the user navigates away\n      window.addEventListener('beforeunload', this.sendPendingTrackingEvents);\n    }\n  }\n\n  sendPendingTrackingEvents = () => {\n    const entries = this.pendingAccumulatedEvents.entries();\n\n    for (let [key, value] of entries) {\n      if (!value.sent) {\n        const event = {\n          datasource: value.datasource.toString(),\n          requestCount: value.requestCount.toString(),\n          savedBytesTotal: value.savedBytesTotal.toString(),\n          initialRequestSize: value.initialRequestSize.toString(),\n          lastRequestSize: value.lastRequestSize.toString(),\n          panelId: value.panelId.toString(),\n          dashId: value.dashId.toString(),\n          expr: value.expr.toString(),\n          refreshIntervalMs: value.refreshIntervalMs.toString(),\n          from: value.from.toString(),\n          queryRangeSeconds: value.queryRangeSeconds.toString(),\n        };\n\n        if (config.featureToggles.prometheusIncrementalQueryInstrumentation) {\n          reportInteraction('grafana_incremental_queries_profile', event);\n        } else if (faro.api.pushEvent) {\n          faro.api.pushEvent('incremental query response size', event, 'no-interaction', {\n            skipDedupe: true,\n          });\n        }\n\n        this.pendingAccumulatedEvents.set(key, {\n          ...value,\n          sent: true,\n          requestCount: 0,\n          savedBytesTotal: 0,\n          initialRequestSize: 0,\n          lastRequestSize: 0,\n        });\n      }\n    }\n  };\n\n  // can be used to change full range request to partial, split into multiple requests\n  requestInfo(request: DataQueryRequest<T>): CacheRequestInfo<T> {\n    // TODO: align from/to to interval to increase probability of hitting backend cache\n\n    const newFrom = request.range.from.valueOf();\n    const newTo = request.range.to.valueOf();\n\n    // only cache 'now'-relative queries (that can benefit from a backfill cache)\n    const shouldCache = request.rangeRaw?.to?.toString() === 'now';\n\n    // all targets are queried together, so we check for any that causes group cache invalidation & full re-query\n    let doPartialQuery = shouldCache;\n    let prevTo: TimestampMs | undefined = undefined;\n\n    const refreshIntervalMs = request.intervalMs;\n\n    // pre-compute reqTargSigs\n    const reqTargSigs = new Map<TargetIdent, TargetSig>();\n    request.targets.forEach((targ) => {\n      let targIdent = `${request.dashboardUID}|${request.panelId}|${targ.refId}`;\n      let targSig = this.getTargetSignature(request, targ); // ${request.maxDataPoints} ?\n\n      if (this.shouldProfile && this.getProfileData) {\n        this.pendingRequestIdsToTargSigs.set(request.requestId, {\n          ...this.getProfileData(request, targ),\n          identity: targIdent + '|' + targSig,\n          bytes: null,\n          panelId: request.panelId,\n          dashboardUID: request.dashboardUID ?? '',\n          from: request.rangeRaw?.from.toString() ?? '',\n          queryRangeSeconds: request.range.to.diff(request.range.from, 'seconds') ?? '',\n          refreshIntervalMs: refreshIntervalMs ?? 0,\n        });\n      }\n\n      reqTargSigs.set(targIdent, targSig);\n    });\n\n    // figure out if new query range or new target props trigger full cache invalidation & re-query\n    for (const [targIdent, targSig] of reqTargSigs) {\n      let cached = this.cache.get(targIdent);\n      let cachedSig = cached?.sig;\n\n      if (cachedSig !== targSig) {\n        doPartialQuery = false;\n      } else {\n        // only do partial queries when new request range follows prior request range (possibly with overlap)\n        // e.g. now-6h with refresh <= 6h\n        prevTo = cached?.prevTo ?? Infinity;\n\n        doPartialQuery = newTo > prevTo && newFrom <= prevTo;\n      }\n\n      if (!doPartialQuery) {\n        break;\n      }\n    }\n\n    if (doPartialQuery && prevTo) {\n      // clamp to make sure we don't re-query previous 10m when newFrom is ahead of it (e.g. 5min range, 30s refresh)\n      let newFromPartial = Math.max(prevTo - this.overlapWindowMs, newFrom);\n\n      const newToDate = dateTime(newTo);\n      const newFromPartialDate = dateTime(incrRoundDn(newFromPartial, request.intervalMs));\n\n      // modify to partial query\n      request = {\n        ...request,\n        range: {\n          ...request.range,\n          from: newFromPartialDate,\n          to: newToDate,\n        },\n      };\n    } else {\n      reqTargSigs.forEach((targSig, targIdent) => {\n        this.cache.delete(targIdent);\n      });\n    }\n\n    return {\n      requests: [request],\n      targSigs: reqTargSigs,\n      shouldCache,\n    };\n  }\n\n  // should amend existing cache with new frames and return full response\n  procFrames(\n    request: DataQueryRequest<T>,\n    requestInfo: CacheRequestInfo<T> | undefined,\n    respFrames: DataFrame[]\n  ): DataFrame[] {\n    if (requestInfo?.shouldCache) {\n      const newFrom = request.range.from.valueOf();\n      const newTo = request.range.to.valueOf();\n\n      // group frames by targets\n      const respByTarget = new Map<TargetIdent, DataFrame[]>();\n\n      respFrames.forEach((frame: DataFrame) => {\n        let targIdent = `${request.dashboardUID}|${request.panelId}|${frame.refId}`;\n\n        let frames = respByTarget.get(targIdent);\n\n        if (!frames) {\n          frames = [];\n          respByTarget.set(targIdent, frames);\n        }\n\n        frames.push(frame);\n      });\n\n      let outFrames: DataFrame[] = [];\n\n      respByTarget.forEach((respFrames, targIdent) => {\n        let cachedFrames = (targIdent ? this.cache.get(targIdent)?.frames : null) ?? [];\n\n        respFrames.forEach((respFrame: DataFrame) => {\n          // skip empty frames\n          if (respFrame.length === 0 || respFrame.fields.length === 0) {\n            return;\n          }\n\n          // frames are identified by their second (non-time) field's name + labels\n          // TODO: maybe also frame.meta.type?\n          let respFrameIdent = getFieldIdent(respFrame.fields[1]);\n\n          let cachedFrame = cachedFrames.find((cached) => getFieldIdent(cached.fields[1]) === respFrameIdent);\n\n          if (!cachedFrame) {\n            // append new unknown frames\n            cachedFrames.push(respFrame);\n          } else {\n            // we assume that fields cannot appear/disappear and will all exist in same order\n\n            // amend & re-cache\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            let prevTable: Table = cachedFrame.fields.map((field) => field.values) as Table;\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            let nextTable: Table = respFrame.fields.map((field) => field.values) as Table;\n\n            let amendedTable = amendTable(prevTable, nextTable);\n            if (amendedTable) {\n              for (let i = 0; i < amendedTable.length; i++) {\n                cachedFrame.fields[i].values = amendedTable[i];\n              }\n              cachedFrame.length = cachedFrame.fields[0].values.length;\n            }\n          }\n        });\n\n        // trim all frames to in-view range, evict those that end up with 0 length\n        let nonEmptyCachedFrames: DataFrame[] = [];\n\n        cachedFrames.forEach((frame) => {\n          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n          let table: Table = frame.fields.map((field) => field.values) as Table;\n\n          let trimmed = trimTable(table, newFrom, newTo);\n\n          if (trimmed[0].length > 0) {\n            for (let i = 0; i < trimmed.length; i++) {\n              frame.fields[i].values = trimmed[i];\n            }\n            nonEmptyCachedFrames.push(frame);\n          }\n        });\n\n        this.cache.set(targIdent, {\n          sig: requestInfo.targSigs.get(targIdent)!,\n          frames: nonEmptyCachedFrames,\n          prevTo: newTo,\n        });\n\n        outFrames.push(...nonEmptyCachedFrames);\n      });\n\n      // transformV2 mutates field values for heatmap de-accum, and modifies field order, so we gotta clone here, for now :(\n      respFrames = outFrames.map((frame) => ({\n        ...frame,\n        fields: frame.fields.map((field) => ({\n          ...field,\n          config: {\n            ...field.config, // prevents mutatative exemplars links (re)enrichment\n          },\n          values: field.values.slice(),\n        })),\n      }));\n    }\n\n    return respFrames;\n  }\n}\n"],"names":["_a","_b","_c","respFrames"],"mappings":"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"}